# ğŸ“‹ è¦ä»¶å®šç¾©æ›¸ã«åŸºã¥ãå®Ÿè£…è¨ˆç”»

**ä½œæˆæ—¥æ™‚**: 2025-10-11 18:30 JST  
**å‚ç…§æ–‡æ›¸**: REQ-SPEC-001  
**Status**: âœ… **å®Ÿè£…è¨ˆç”»ç¢ºå®š**

---

## ğŸ“Š ç¾çŠ¶åˆ†æ

### å®Ÿè£…æ¸ˆã¿æ©Ÿèƒ½ï¼ˆâœ…ï¼‰

#### ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ©Ÿæ§‹
- **FR-SA-001**: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®šç¾©ï¼ˆYAMLï¼‰ âœ…
- **FR-SA-002**: delegate ã‚³ãƒãƒ³ãƒ‰ âœ…ï¼ˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
- **FR-SA-004**: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆç¨®é¡ï¼ˆ7ç¨®ï¼‰ âœ…ï¼ˆå®šç¾©ã®ã¿ï¼‰

#### Deep Researchæ©Ÿèƒ½
- **FR-DR-001**: research ã‚³ãƒãƒ³ãƒ‰ âœ…
- **FR-DR-002**: Webæ¤œç´¢çµ±åˆ âœ…ï¼ˆDuckDuckGoå®Œäº†ï¼‰
- **FR-DR-003**: å¤šæ®µéšæ¢ç´¢ âœ…
- **FR-DR-004**: çŸ›ç›¾æ¤œå‡º âœ…
- **FR-DR-005**: å¼•ç”¨ç®¡ç† âœ…
- **FR-DR-006**: ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ âœ…

---

### æœªå®Ÿè£…æ©Ÿèƒ½ï¼ˆğŸš§ï¼‰

#### ğŸ”´ Criticalå„ªå…ˆåº¦
1. **FR-SA-003**: Agent Runtime
2. **FR-SA-005**: æ¨©é™ç®¡ç†

#### ğŸŸ¡ Highå„ªå…ˆåº¦
3. **FR-SA-006**: ãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚¸ã‚§ãƒƒãƒˆç®¡ç†
4. **FR-CM-001**: å¯¾è©±ãƒ¢ãƒ¼ãƒ‰çµ±åˆ
5. **FR-CM-002**: MCPãƒ„ãƒ¼ãƒ«çµ±åˆ
6. **FR-CM-003**: ãƒ­ã‚°ãƒ»ç›£æŸ»

---

## ğŸ¯ å®Ÿè£…è¨ˆç”»

### Phase 1: Agent RuntimeåŸºç›¤ï¼ˆ2é€±é–“ï¼‰

**ç›®æ¨™**: FR-SA-003 Agent Runtime å®Ÿè£…

#### ã‚¿ã‚¹ã‚¯1-1: ãƒ‡ãƒ¼ã‚¿æ§‹é€ å®šç¾©ï¼ˆ2æ—¥ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/core/src/agent_runtime.rs`

```rust
use anyhow::Result;
use std::collections::HashMap;
use tokio::time::{timeout, Duration};

/// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®Ÿè¡Œç’°å¢ƒ
pub struct AgentRuntime {
    pub agent_def: AgentDefinition,
    pub budget: TokenBudget,
    pub permissions: PermissionSet,
    pub executor: TaskExecutor,
}

impl AgentRuntime {
    /// æ–°ã—ã„AgentRuntimeã‚’ä½œæˆ
    pub fn new(
        agent_def: AgentDefinition,
        budget: TokenBudget,
        permissions: PermissionSet,
        executor: TaskExecutor,
    ) -> Result<Self> {
        Ok(Self {
            agent_def,
            budget,
            permissions,
            executor,
        })
    }

    /// ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
    pub async fn execute_task(
        &mut self,
        goal: &str,
        inputs: &HashMap<String, String>,
    ) -> Result<AgentExecutionResult> {
        // 1. ãƒã‚¸ã‚§ãƒƒãƒˆãƒã‚§ãƒƒã‚¯
        if !self.budget.check_available(1000) {
            return Err(anyhow::anyhow!("Insufficient token budget"));
        }

        // 2. å®Ÿè¡Œæ™‚é–“åˆ¶é™ä»˜ãã§ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
        let deadline = Duration::from_secs(
            self.agent_def.timeout_seconds.unwrap_or(300) as u64
        );
        
        let start = std::time::Instant::now();
        
        let result = timeout(deadline, self.executor.execute(goal, inputs))
            .await
            .map_err(|_| anyhow::anyhow!("Task execution timeout"))?;

        let duration = start.elapsed();

        // 3. çµæœå‡¦ç†
        match result {
            Ok(output) => {
                self.budget.consume(output.tokens_used)?;
                
                Ok(AgentExecutionResult {
                    status: AgentExecutionStatus::Success,
                    tokens_used: output.tokens_used,
                    duration_secs: duration.as_secs_f64(),
                    artifacts: output.artifacts,
                    message: Some(output.message),
                    error: None,
                })
            }
            Err(e) => {
                Ok(AgentExecutionResult {
                    status: AgentExecutionStatus::Failed,
                    tokens_used: 0,
                    duration_secs: duration.as_secs_f64(),
                    artifacts: vec![],
                    message: None,
                    error: Some(e.to_string()),
                })
            }
        }
    }
}
```

**å—å…¥åŸºæº–**:
- [ ] AgentRuntimeæ§‹é€ ä½“å®šç¾©
- [ ] new()ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…
- [ ] execute_task()ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆ3ä»¶ä»¥ä¸Š

---

#### ã‚¿ã‚¹ã‚¯1-2: TaskExecutorå®Ÿè£…ï¼ˆ3æ—¥ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/core/src/task_executor.rs`

```rust
use anyhow::Result;
use std::collections::HashMap;

/// ã‚¿ã‚¹ã‚¯å®Ÿè¡Œçµæœ
pub struct TaskOutput {
    pub tokens_used: usize,
    pub artifacts: Vec<String>,
    pub message: String,
}

/// ã‚¿ã‚¹ã‚¯å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³
pub struct TaskExecutor {
    // MCPã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã€LLMã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãªã©
}

impl TaskExecutor {
    pub fn new() -> Self {
        Self {}
    }

    /// ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
    pub async fn execute(
        &self,
        goal: &str,
        inputs: &HashMap<String, String>,
    ) -> Result<TaskOutput> {
        // TODO: å®Ÿéš›ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
        // - LLMå‘¼ã³å‡ºã—
        // - MCPãƒ„ãƒ¼ãƒ«ä½¿ç”¨
        // - çµæœé›†ç´„
        
        Ok(TaskOutput {
            tokens_used: 1000,
            artifacts: vec!["output.md".to_string()],
            message: format!("Task completed: {}", goal),
        })
    }
}
```

**å—å…¥åŸºæº–**:
- [ ] TaskExecutoræ§‹é€ ä½“å®šç¾©
- [ ] execute()ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…
- [ ] MCPãƒ„ãƒ¼ãƒ«çµ±åˆ
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆ5ä»¶ä»¥ä¸Š

---

#### ã‚¿ã‚¹ã‚¯1-3: delegate ã‚³ãƒãƒ³ãƒ‰çµ±åˆï¼ˆ2æ—¥ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/cli/src/delegate_cmd.rs`

```rust
pub async fn run_delegate_command(
    agent: String,
    goal: Option<String>,
    scope: Option<PathBuf>,
    budget: Option<usize>,
    deadline: Option<u64>,
    out: Option<PathBuf>,
) -> Result<()> {
    println!("ğŸ¤– Delegating to sub-agent '{}'...", agent);

    // 1. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®šç¾©èª­ã¿è¾¼ã¿
    let agent_def = load_agent_definition(&agent)?;
    
    // 2. AgentRuntimeåˆæœŸåŒ–
    let budget = TokenBudget::new(budget.unwrap_or(agent_def.max_tokens));
    let permissions = PermissionSet::from_agent_def(&agent_def)?;
    let executor = TaskExecutor::new();
    
    let mut runtime = AgentRuntime::new(
        agent_def,
        budget,
        permissions,
        executor,
    )?;

    // 3. ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
    let mut inputs = HashMap::new();
    if let Some(scope_path) = scope {
        inputs.insert("scope".to_string(), scope_path.display().to_string());
    }

    let goal_str = goal.unwrap_or_else(|| "Perform delegated task".to_string());
    let result = runtime.execute_task(&goal_str, &inputs).await?;

    // 4. çµæœè¡¨ç¤º
    println!("\nâœ… Agent '{}' completed!", agent);
    println!("   Status: {:?}", result.status);
    println!("   Tokens used: {}", result.tokens_used);
    println!("   Duration: {:.2}s", result.duration_secs);

    // 5. çµæœä¿å­˜
    if let Some(out_path) = out {
        let report = serde_json::to_string_pretty(&result)?;
        std::fs::write(&out_path, report)?;
        println!("\nğŸ’¾ Result saved to: {}", out_path.display());
    }

    Ok(())
}
```

**å—å…¥åŸºæº–**:
- [ ] AgentRuntimeçµ±åˆ
- [ ] å®Ÿéš›ã®ã‚¿ã‚¹ã‚¯å®Ÿè¡Œ
- [ ] çµæœè¡¨ç¤ºãƒ»ä¿å­˜
- [ ] E2Eãƒ†ã‚¹ãƒˆæˆåŠŸ

---

### Phase 2: æ¨©é™ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆ1é€±é–“ï¼‰

**ç›®æ¨™**: FR-SA-005 æ¨©é™ç®¡ç† å®Ÿè£…

#### ã‚¿ã‚¹ã‚¯2-1: PermissionSetå®Ÿè£…ï¼ˆ3æ—¥ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/core/src/permissions.rs`

```rust
use anyhow::Result;
use std::path::{Path, PathBuf};

/// æ¨©é™ã‚»ãƒƒãƒˆ
#[derive(Debug, Clone)]
pub struct PermissionSet {
    pub file_read: FilePermission,
    pub file_write: FilePermission,
    pub shell: ShellPermission,
    pub network: NetworkPermission,
    pub mcp_tools: Vec<String>,
}

impl PermissionSet {
    /// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå®šç¾©ã‹ã‚‰æ¨©é™ã‚»ãƒƒãƒˆä½œæˆ
    pub fn from_agent_def(agent_def: &AgentDefinition) -> Result<Self> {
        Ok(Self {
            file_read: FilePermission::from_yaml(&agent_def.permissions.file_read)?,
            file_write: FilePermission::from_yaml(&agent_def.permissions.file_write)?,
            shell: ShellPermission::from_yaml(agent_def.permissions.shell)?,
            network: NetworkPermission::from_yaml(agent_def.permissions.network)?,
            mcp_tools: agent_def.tools.clone().unwrap_or_default(),
        })
    }

    /// ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿å–ã‚Šæ¨©é™ãƒã‚§ãƒƒã‚¯
    pub fn check_file_read(&self, path: &Path) -> Result<()> {
        self.file_read.check(path)
    }

    /// ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿æ¨©é™ãƒã‚§ãƒƒã‚¯
    pub fn check_file_write(&self, path: &Path) -> Result<()> {
        self.file_write.check(path)
    }

    /// ã‚·ã‚§ãƒ«ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œæ¨©é™ãƒã‚§ãƒƒã‚¯
    pub fn check_shell_command(&self, command: &str) -> Result<()> {
        self.shell.check(command)
    }

    /// ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãƒã‚§ãƒƒã‚¯
    pub fn check_network_access(&self, url: &str) -> Result<()> {
        self.network.check(url)
    }
}

/// ãƒ•ã‚¡ã‚¤ãƒ«æ¨©é™
#[derive(Debug, Clone)]
pub enum FilePermission {
    None,
    ReadOnly(Vec<PathBuf>),
    ReadWrite(Vec<PathBuf>),
    Restricted(Vec<PathBuf>),
}

impl FilePermission {
    pub fn check(&self, path: &Path) -> Result<()> {
        match self {
            FilePermission::None => {
                Err(anyhow::anyhow!("File access denied"))
            }
            FilePermission::ReadOnly(allowed) => {
                if allowed.iter().any(|p| path.starts_with(p)) {
                    Ok(())
                } else {
                    Err(anyhow::anyhow!(
                        "Path not in allowed list: {}",
                        path.display()
                    ))
                }
            }
            FilePermission::ReadWrite(allowed) => {
                if allowed.iter().any(|p| path.starts_with(p)) {
                    Ok(())
                } else {
                    Err(anyhow::anyhow!(
                        "Path not in allowed list: {}",
                        path.display()
                    ))
                }
            }
            FilePermission::Restricted(restricted) => {
                if restricted.iter().any(|p| path.starts_with(p)) {
                    Err(anyhow::anyhow!(
                        "Path is restricted: {}",
                        path.display()
                    ))
                } else {
                    Ok(())
                }
            }
        }
    }
}
```

**å—å…¥åŸºæº–**:
- [ ] PermissionSetæ§‹é€ ä½“å®šç¾©
- [ ] å„æ¨©é™ãƒã‚§ãƒƒã‚¯ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…
- [ ] YAMLèª­ã¿è¾¼ã¿æ©Ÿèƒ½
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆ10ä»¶ä»¥ä¸Š

---

#### ã‚¿ã‚¹ã‚¯2-2: ç›£æŸ»ãƒ­ã‚°ï¼ˆ2æ—¥ï¼‰

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/core/src/audit_log.rs`

```rust
use serde::{Serialize, Deserialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize)]
pub struct AuditLogEntry {
    pub timestamp: DateTime<Utc>,
    pub agent: String,
    pub action: AuditAction,
    pub result: AuditResult,
    pub details: serde_json::Value,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum AuditAction {
    FileRead(String),
    FileWrite(String),
    ShellCommand(String),
    NetworkAccess(String),
    AgentExecution,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum AuditResult {
    Allowed,
    Denied,
    Error(String),
}

impl AuditLogEntry {
    pub fn log(&self) {
        let json = serde_json::to_string(self).unwrap();
        eprintln!("[AUDIT] {}", json);
        // TODO: ãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚‚ä¿å­˜
    }
}
```

**å—å…¥åŸºæº–**:
- [ ] ç›£æŸ»ãƒ­ã‚°è¨˜éŒ²
- [ ] JSONå½¢å¼å‡ºåŠ›
- [ ] ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
- [ ] ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³

---

### Phase 3: ãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚¸ã‚§ãƒƒãƒˆç®¡ç†ï¼ˆ3æ—¥ï¼‰

**ç›®æ¨™**: FR-SA-006 ãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚¸ã‚§ãƒƒãƒˆç®¡ç† å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `codex-rs/core/src/token_budget.rs`

```rust
use anyhow::Result;

/// ãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚¸ã‚§ãƒƒãƒˆ
#[derive(Debug, Clone)]
pub struct TokenBudget {
    pub total: usize,
    pub used: usize,
    pub reserved: usize,
}

impl TokenBudget {
    pub fn new(total: usize) -> Self {
        Self {
            total,
            used: 0,
            reserved: 0,
        }
    }

    /// åˆ©ç”¨å¯èƒ½ã‹ç¢ºèª
    pub fn check_available(&self, required: usize) -> bool {
        self.remaining() >= required
    }

    /// ãƒˆãƒ¼ã‚¯ãƒ³æ¶ˆè²»
    pub fn consume(&mut self, amount: usize) -> Result<()> {
        if !self.check_available(amount) {
            return Err(anyhow::anyhow!(
                "Insufficient token budget: required={}, remaining={}",
                amount,
                self.remaining()
            ));
        }
        self.used += amount;
        Ok(())
    }

    /// ãƒˆãƒ¼ã‚¯ãƒ³äºˆç´„è§£æ”¾
    pub fn release(&mut self, amount: usize) {
        self.reserved = self.reserved.saturating_sub(amount);
    }

    /// æ®‹é‡
    pub fn remaining(&self) -> usize {
        self.total.saturating_sub(self.used + self.reserved)
    }

    /// ä½¿ç”¨ç‡ï¼ˆ%ï¼‰
    pub fn usage_rate(&self) -> f64 {
        (self.used as f64 / self.total as f64) * 100.0
    }
}
```

**å—å…¥åŸºæº–**:
- [ ] TokenBudgetæ§‹é€ ä½“å®šç¾©
- [ ] å„ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…
- [ ] å˜ä½“ãƒ†ã‚¹ãƒˆ8ä»¶ä»¥ä¸Š
- [ ] ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãƒ†ã‚¹ãƒˆ

---

### Phase 4: å¯¾è©±ãƒ¢ãƒ¼ãƒ‰çµ±åˆï¼ˆ1é€±é–“ï¼‰

**ç›®æ¨™**: FR-CM-001 å¯¾è©±ãƒ¢ãƒ¼ãƒ‰çµ±åˆ

**å®Ÿè£…å†…å®¹**:
```rust
// codex-rs/core/src/interactive_mode.rs

// @code-reviewer ã‚¨ã‚¤ãƒªã‚¢ã‚¹å‡¦ç†
if input.starts_with("@code-reviewer ") {
    let scope = input.strip_prefix("@code-reviewer ").unwrap();
    return run_delegate_command(
        "code-reviewer".to_string(),
        None,
        Some(PathBuf::from(scope)),
        None,
        None,
        None,
    ).await;
}

// @researcher ã‚¨ã‚¤ãƒªã‚¢ã‚¹å‡¦ç†
if input.starts_with("@researcher ") {
    let query = input.strip_prefix("@researcher ").unwrap();
    return run_research_command(
        query.to_string(),
        1,
        3,
        ResearchStrategy::Comprehensive,
        None,
        None,
    ).await;
}
```

---

## ğŸ“… å®Ÿè£…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

| Phase | æœŸé–“ | ã‚¿ã‚¹ã‚¯ | æ‹…å½“ |
|-------|------|--------|------|
| **Phase 1** | Week 1-2 | Agent RuntimeåŸºç›¤ | Development Team |
| **Phase 2** | Week 3 | æ¨©é™ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  | Development Team |
| **Phase 3** | Week 4 å‰åŠ | ãƒˆãƒ¼ã‚¯ãƒ³ãƒã‚¸ã‚§ãƒƒãƒˆç®¡ç† | Development Team |
| **Phase 4** | Week 4 å¾ŒåŠ | å¯¾è©±ãƒ¢ãƒ¼ãƒ‰çµ±åˆ | Development Team |

---

## âœ… å®Œäº†æ¡ä»¶

### Phase 1å®Œäº†æ¡ä»¶
- [ ] AgentRuntimeå®Ÿè£…ãƒ»ãƒ†ã‚¹ãƒˆå®Œäº†
- [ ] TaskExecutorå®Ÿè£…ãƒ»ãƒ†ã‚¹ãƒˆå®Œäº†
- [ ] delegate ã‚³ãƒãƒ³ãƒ‰å®Ÿå‹•ä½œ
- [ ] `cargo test -p codex-core` æˆåŠŸ

### Phase 2å®Œäº†æ¡ä»¶
- [ ] PermissionSetå®Ÿè£…ãƒ»ãƒ†ã‚¹ãƒˆå®Œäº†
- [ ] ç›£æŸ»ãƒ­ã‚°å®Ÿè£…å®Œäº†
- [ ] æ¨©é™ãƒã‚§ãƒƒã‚¯å‹•ä½œç¢ºèª
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆå®Œäº†

### Phase 3å®Œäº†æ¡ä»¶
- [ ] TokenBudgetå®Ÿè£…ãƒ»ãƒ†ã‚¹ãƒˆå®Œäº†
- [ ] ãƒã‚¸ã‚§ãƒƒãƒˆç®¡ç†å‹•ä½œç¢ºèª
- [ ] ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼å¯¾ç­–ç¢ºèª

### Phase 4å®Œäº†æ¡ä»¶
- [ ] å¯¾è©±ãƒ¢ãƒ¼ãƒ‰çµ±åˆå®Œäº†
- [ ] @ã‚¨ã‚¤ãƒªã‚¢ã‚¹å‹•ä½œç¢ºèª
- [ ] E2Eãƒ†ã‚¹ãƒˆå®Œäº†

---

## ğŸ¯ æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³

### ä»Šã™ãï¼ˆä»Šæ—¥ï¼‰

```bash
# Phase 1é–‹å§‹
1. ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä½œæˆ
mkdir -p codex-rs/core/src

2. ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
touch codex-rs/core/src/agent_runtime.rs
touch codex-rs/core/src/task_executor.rs
touch codex-rs/core/src/permissions.rs
touch codex-rs/core/src/token_budget.rs
touch codex-rs/core/src/audit_log.rs

3. Cargo.tomlæ›´æ–°
# codex-rs/core/Cargo.toml ã«ä¾å­˜é–¢ä¿‚è¿½åŠ 
```

### æ˜æ—¥

```bash
# AgentRuntimeå®Ÿè£…é–‹å§‹
1. agent_runtime.rs å®Ÿè£…
2. å˜ä½“ãƒ†ã‚¹ãƒˆä½œæˆ
3. cargo testå®Ÿè¡Œ
```

---

## ğŸ’¡ å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ

### 1. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```rust
// âœ… Good
pub fn execute(&self) -> Result<Output> {
    self.check_permissions()?;
    self.check_budget()?;
    // ...
}

// âŒ Bad
pub fn execute(&self) -> Output {
    self.check_permissions().unwrap();  // panicå¯èƒ½æ€§
    // ...
}
```

### 2. éåŒæœŸå‡¦ç†

```rust
// âœ… Good
pub async fn execute_task(&mut self, ...) -> Result<Output> {
    let result = timeout(deadline, async {
        // ...
    }).await?;
}
```

### 3. ãƒ†ã‚¹ãƒˆ

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_agent_runtime_execute() {
        let runtime = AgentRuntime::new(...).unwrap();
        let result = runtime.execute_task("test", &inputs).await;
        assert!(result.is_ok());
    }
}
```

---

## ğŸŠ å®Œäº†å®£è¨€

**ã“ã®å®Ÿè£…è¨ˆç”»ã«å¾“ãˆã°ã€4é€±é–“ã§  
ã‚µãƒ–ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆæ©Ÿæ§‹ãŒå®Œå…¨ã«å‹•ä½œã™ã‚‹ã§ï¼** ğŸ’ª

---

**ä½œæˆæ—¥æ™‚**: 2025-10-11 18:30 JST  
**å‚ç…§æ–‡æ›¸**: REQ-SPEC-001  
**Status**: âœ… **å®Ÿè£…è¨ˆç”»ç¢ºå®š**

---

**END OF IMPLEMENTATION PLAN**

