# Codex Rustå®Ÿè£… 30æ—¥ã‚¹ãƒ—ãƒªãƒ³ãƒˆå®Ÿè£…è¨ˆç”»

**æ—¥æ™‚**: 2025å¹´10æœˆ8æ—¥ 0:20 JST  
**ä½œæ¥­è€…**: AI Assistant (ãªã‚“Jé¢¨) + ãƒœãƒ–ã«ã‚ƒã‚“ã®èµ¤ãƒšãƒ³æŒ‡å°  
**ç›®çš„**: "Rustã§ãªãã‚ƒç„¡ç†"ã‚’å®šé‡ã§è¨¼æ˜ã™ã‚‹å®Ÿå‹™ãƒ¬ãƒ™ãƒ«CLIæ§‹ç¯‰

å‚è€ƒï¼š
- ãƒœãƒ–ã«ã‚ƒã‚“èµ¤ãƒšãƒ³ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
- gemini-cli: https://github.com/zapabob/gemini-cli
- å…¬å¼Codex: https://github.com/openai/codex

---

## ğŸ¯ å®Œæˆãƒ©ã‚¤ãƒ³ï¼ˆDoD: Definition of Doneï¼‰

ä»¥ä¸‹ã®5ç‚¹ãŒæƒãˆã° **"Rustã§ãªãã‚ƒé”æˆä¸èƒ½"** ãŒè¨¼æ˜ã§ãã‚‹ï¼š

1. âœ… **æ—¢å®šãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«=Offline**ã€æ˜æ–‡åŒ– & å®Ÿè£… & ãƒ†ã‚¹ãƒˆ ãŒä¸€è‡´
2. âœ… **CIè„±ç„E2E** ãŒ 3ç³»çµ±ã§ç·‘ã€æ‹’å¦ç†ç”±ãŒç›£æŸ»ãƒ­ã‚°ã«æ®‹ã‚‹
3. âœ… **`cosign verify` + `sbom.json`** ã®æ¤œè¨¼æ‰‹é †ãŒREADMEã«è¨˜è¼‰
4. âœ… **A/Bãƒ™ãƒ³ãƒãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰** ã§ Cold<80ms / RSS<30MB ã‚’å¸¸æ™‚æº€ãŸã™
5. âœ… **WASM ã¨ MCP ã®æ¨©é™å·®** ãŒäººé–“ã«èª¬æ˜ã§ãã‚‹ãƒ¬ãƒ™ãƒ«ã§æ˜è¨˜

---

## ğŸ“… 30æ—¥ã‚¹ãƒ—ãƒªãƒ³ãƒˆè¨ˆç”»ï¼ˆè§¦ã‚Œã‚‹æˆæœç‰©å„ªå…ˆï¼‰

### Week 1: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£åŸºç›¤ï¼ˆOfflineæ—¢å®šåŒ–ï¼‰

#### Day 1-2: æ—¢å®šãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«å¤‰æ›´

**å®Ÿè£…**:
```rust
// codex-rs/protocol/src/protocol.rs
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum SecurityProfile {
    /// æ—¢å®šï¼šãƒãƒƒãƒˆé®æ–­ + ãƒ‡ã‚£ã‚¹ã‚¯èª­ã¿å–ã‚Šã®ã¿
    #[default]
    Offline,
    /// ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹æ›¸ãè¾¼ã¿å¯ï¼ˆãƒãƒƒãƒˆé®æ–­ï¼‰
    WorkspaceWrite,
    /// ãƒãƒƒãƒˆèª­ã¿å–ã‚Šå¯
    NetReadOnly,
    /// ãƒ•ãƒ«æ¨©é™ï¼ˆè¦æ˜ç¤ºï¼‰
    Trusted,
}

impl Default for SandboxPolicy {
    fn default() -> Self {
        // Offline = ReadOnly + network_access=false
        SandboxPolicy::ReadOnly
    }
}
```

**ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**:
```markdown
# docs/security-profiles.md

## Default Profile: Offline(ReadOnly)

| æ“ä½œ | è¨±å¯ | ç†ç”± |
|---|---|---|
| ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿å–ã‚Š | âœ… | ã‚³ãƒ¼ãƒ‰è§£æã«å¿…è¦ |
| ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿ | âŒ | ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹å¤–ä¿è­· |
| ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ | âŒ | ãƒ‡ãƒ¼ã‚¿æ¼æ´©é˜²æ­¢ |
| ãƒ—ãƒ­ã‚»ã‚¹ç”Ÿæˆ | âŒ | è¨±å¯ãƒªã‚¹ãƒˆã®ã¿ |

### ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æ˜‡æ ¼
`--profile workspace-write` ã¾ãŸã¯ `/profile workspace-write` ã§ä¸€æ™‚æ˜‡æ ¼
```

**æˆæœç‰©**:
- [ ] `codex-rs/protocol/src/security_profile.rs` (æ–°è¦)
- [ ] `docs/security-profiles.md` (æ–°è¦)
- [ ] ãƒ†ã‚¹ãƒˆ: `test_default_is_offline()`

#### Day 3-4: ç¸®é€€ä»•æ§˜ã®å®Ÿè£…

**å®Ÿè£…**:
```rust
// codex-rs/core/src/executor/sandbox.rs
pub fn get_effective_sandbox(policy: SandboxPolicy) -> EffectiveSandbox {
    #[cfg(target_os = "linux")]
    if landlock::is_available() {
        return EffectiveSandbox::Landlock(policy);
    }
    
    #[cfg(target_os = "macos")]
    if seatbelt::is_available() {
        return EffectiveSandbox::Seatbelt(policy);
    }
    
    #[cfg(target_os = "windows")]
    if appcontainer::is_available() {
        return EffectiveSandbox::AppContainer(policy);
    }
    
    // ç¸®é€€ï¼šå…¨ç’°å¢ƒå…±é€šã®æœ€å°é™åˆ¶å¾¡
    EffectiveSandbox::Degraded {
        network_blocked: true,
        workspace_only_write: true,
        spawn_denied: true,
    }
}
```

**ç¸®é€€è¡¨**:
```markdown
| ç’°å¢ƒ | å„ªå…ˆå®Ÿè£… | ç¸®é€€å…ˆ |
|---|---|---|
| Linux | Landlock | seccomp-bpf |
| macOS | Seatbelt | process sandbox |
| Windows | AppContainer | Job Object |
| ãã®ä»– | - | ãƒãƒƒãƒˆé®æ–­+spawnåˆ¶é™ |
```

**æˆæœç‰©**:
- [ ] `codex-rs/core/src/executor/degraded_sandbox.rs` (æ–°è¦)
- [ ] `docs/sandbox-degradation.md` (æ–°è¦)

#### Day 5-7: è„±ç„E2Eãƒ†ã‚¹ãƒˆ

**å®Ÿè£…**:
```rust
// codex-rs/core/tests/suite/sandbox_escape.rs (æ–°è¦)
use pretty_assertions::assert_eq;

#[tokio::test]
async fn test_sandbox_blocks_network_dns() {
    let result = execute_sandboxed("nslookup google.com").await;
    assert!(result.is_err());
    // ç›£æŸ»ãƒ­ã‚°ã«è¨˜éŒ²ã•ã‚Œã‚‹ã“ã¨ã‚’ç¢ºèª
    let audit = get_last_audit_entry();
    assert_eq!(audit.operation, "network_access");
    assert_eq!(audit.decision, Decision::Denied);
    assert!(audit.reason.contains("Offline profile"));
}

#[tokio::test]
async fn test_sandbox_blocks_network_tcp() {
    let result = execute_sandboxed("curl http://example.com").await;
    assert!(result.is_err());
}

#[tokio::test]
async fn test_sandbox_blocks_unauthorized_write() {
    let result = execute_sandboxed("echo test > /etc/passwd").await;
    assert!(result.is_err());
    let audit = get_last_audit_entry();
    assert_eq!(audit.decision, Decision::Denied);
}

#[tokio::test]
async fn test_sandbox_blocks_process_spawn() {
    let result = execute_sandboxed("bash -c 'python malicious.py'").await;
    assert!(result.is_err());
}
```

**CIè¨­å®š**:
```yaml
# .github/workflows/security-tests.yml (æ–°è¦)
name: Security Tests
on: [push, pull_request]

jobs:
  sandbox-escape-tests:
    name: Sandbox Escape Tests (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@nightly
      - name: Run sandbox escape tests
        run: |
          cd codex-rs
          cargo test --test sandbox_escape -- --test-threads=1
      - name: Verify audit logs created
        run: |
          test -f audit.log || exit 1
```

**æˆæœç‰©**:
- [ ] `codex-rs/core/tests/suite/sandbox_escape.rs`
- [ ] `.github/workflows/security-tests.yml`
- [ ] 3ç³»çµ±ãƒ†ã‚¹ãƒˆå…¨ã¦ãƒ‘ã‚¹

---

### Week 2: ç›£æŸ»ãƒ­ã‚°ï¼†è¦³æ¸¬æ€§

#### Day 8-10: ç›£æŸ»ãƒ­ã‚°v1

**å®Ÿè£…**:
```rust
// codex-rs/audit/src/lib.rs (æ–°è¦ã‚¯ãƒ¬ãƒ¼ãƒˆ)
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditEntry {
    /// ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆISO 8601ï¼‰
    pub timestamp: DateTime<Utc>,
    /// ã‚¿ã‚¹ã‚¯ID
    pub task_id: String,
    /// ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¿ã‚¤ãƒ—
    pub agent_type: String,
    /// ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«
    pub profile: String,
    /// æ“ä½œç¨®åˆ¥
    pub operation: Operation,
    /// å¯¾è±¡ï¼ˆãƒã‚¹ã‚¯æ¸ˆã¿ï¼‰
    pub target: String,
    /// æ±ºå®š
    pub decision: Decision,
    /// ç†ç”±
    pub reason: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Operation {
    FileRead,
    FileWrite,
    NetworkAccess,
    ProcessSpawn,
    Other(String),
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Decision {
    Allowed,
    Denied,
}

/// ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼é…æ…®ï¼šãƒ‘ã‚¹å†…ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼åã‚’ãƒã‚¹ã‚¯
pub fn sanitize_path(path: &Path) -> String {
    let path_str = path.display().to_string();
    
    // Windows: C:\Users\username â†’ C:\Users\[USER]
    #[cfg(windows)]
    {
        if let Ok(username) = std::env::var("USERNAME") {
            return path_str.replace(&username, "[USER]");
        }
    }
    
    // Unix: /home/username â†’ /home/[USER]
    #[cfg(unix)]
    {
        if let Ok(home) = std::env::var("HOME") {
            return path_str.replace(&home, "[HOME]");
        }
    }
    
    path_str
}

/// ç›£æŸ»ãƒ­ã‚°ãƒ©ã‚¤ã‚¿ãƒ¼
pub struct AuditLogger {
    log_path: PathBuf,
}

impl AuditLogger {
    pub fn new(log_path: PathBuf) -> Self {
        Self { log_path }
    }
    
    pub fn log(&self, entry: AuditEntry) -> std::io::Result<()> {
        use std::io::Write;
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_path)?;
        
        writeln!(file, "{}", serde_json::to_string(&entry)?)?;
        Ok(())
    }
}
```

**æˆæœç‰©**:
- [ ] `codex-rs/audit/` (æ–°è¦ã‚¯ãƒ¬ãƒ¼ãƒˆ)
- [ ] å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰4ç‚¹ã‚»ãƒƒãƒˆå®Ÿè£…
- [ ] ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼ãƒã‚¹ã‚­ãƒ³ã‚°å®Ÿè£…

#### Day 11-12: æ§‹é€ åŒ–ãƒ­ã‚°ï¼†ãƒ¡ãƒˆãƒªã‚¯ã‚¹

**å®Ÿè£…**:
```rust
// codex-rs/supervisor/src/metrics.rs (æ–°è¦)
use opentelemetry::metrics::{Counter, Gauge, Histogram};

pub struct SupervisorMetrics {
    pub task_execution_count: Counter<u64>,
    pub task_execution_duration: Histogram<f64>,
    pub active_agents: Gauge<u64>,
    pub errors_total: Counter<u64>,
    pub denials_total: Counter<u64>,
}

// codex-rs/supervisor/src/integrated.rs ã«è¿½åŠ 
use tracing::{info_span, instrument};

#[instrument(skip(self), fields(
    task_type = %self.get_task_type(&task),
    agent_count = self.agent_manager.get_all_states().len()
))]
pub fn execute_task(
    &mut self,
    task: TaskType,
) -> Pin<Box<dyn Future<Output = Result<TaskExecutionResult>> + '_>> {
    Box::pin(async move {
        let start = std::time::Instant::now();
        
        // ãƒ¡ãƒˆãƒªã‚¯ã‚¹è¨˜éŒ²
        self.metrics.task_execution_count.add(1, &[]);
        
        // ... å®Ÿè£… ...
        
        self.metrics.task_execution_duration.record(
            start.elapsed().as_secs_f64(),
            &[]
        );
        
        Ok(result)
    })
}
```

**æˆæœç‰©**:
- [ ] `codex-rs/supervisor/src/metrics.rs`
- [ ] OTLP ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆè¨­å®š
- [ ] 5ç¨®é¡ã®ãƒ¡ãƒˆãƒªã‚¯ã‚¹å®Ÿè£…

#### Day 13-14: bounded mailbox + ãƒãƒƒã‚¯ãƒ—ãƒ¬ãƒƒã‚·ãƒ£

**å®Ÿè£…**:
```rust
// codex-rs/supervisor/src/subagent.rs æ›´æ–°
use tokio::sync::{mpsc, Semaphore};

pub struct SubAgent {
    agent_type: AgentType,
    state: AgentState,
    tx: mpsc::Sender<AgentMessage>,  // bounded ã«å¤‰æ›´
    rx: mpsc::Receiver<AgentMessage>,
}

impl SubAgent {
    pub fn new(agent_type: AgentType, mailbox_size: usize) -> Self {
        let (tx, rx) = mpsc::channel(mailbox_size);  // bounded: æ—¢å®š32
        // ...
    }
}

#[derive(Debug, Clone)]
pub enum MailboxFullPolicy {
    /// ãƒ–ãƒ­ãƒƒã‚¯ã—ã¦å¾…æ©Ÿ
    Block,
    /// å¤ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤
    DropOldest,
    /// æ–°ã—ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ‹’å¦
    DropNew,
}

pub struct SubAgentManager {
    agents: HashMap<AgentType, SubAgent>,
    semaphore: Arc<Semaphore>,  // åŒæ™‚å®Ÿè¡Œæ•°åˆ¶é™
    mailbox_full_policy: MailboxFullPolicy,
}

impl SubAgentManager {
    pub fn new_with_config(
        max_concurrent: usize,
        mailbox_size: usize,
        full_policy: MailboxFullPolicy,
    ) -> Self {
        Self {
            agents: HashMap::new(),
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
            mailbox_full_policy: full_policy,
        }
    }
}
```

**æˆæœç‰©**:
- [ ] bounded channelå®Ÿè£…
- [ ] Semaphoreã«ã‚ˆã‚‹ã‚¹ãƒ­ãƒƒãƒˆãƒ«
- [ ] MailboxFullPolicyè¨­å®šåŒ–

---

### Week 3: æ‹¡å¼µå¢ƒç•Œï¼ˆWASM/MCPåˆ†é›¢ï¼‰

#### Day 15-17: WASM ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒ¬ãƒ¼ãƒ«

**å®Ÿè£…**:
```rust
// codex-rs/wasm-plugin/src/lib.rs (æ–°è¦ã‚¯ãƒ¬ãƒ¼ãƒˆ)
use wasmtime::{Config, Engine, Linker, Module, Store};
use wasmtime_wasi::{WasiCtx, WasiCtxBuilder};

pub struct WasmPlugin {
    engine: Engine,
    module: Module,
    config: WasmPluginConfig,
}

#[derive(Debug, Clone)]
pub struct WasmPluginConfig {
    /// ç‡ƒæ–™åˆ¶é™ï¼ˆå‘½ä»¤æ•°ï¼‰
    pub fuel_limit: u64,
    /// æ™‚é–“åˆ¶é™
    pub time_limit: Duration,
    /// ãƒ¡ãƒ¢ãƒªåˆ¶é™ï¼ˆãƒã‚¤ãƒˆï¼‰
    pub memory_limit: usize,
    /// è¨±å¯ã™ã‚‹WASIæ©Ÿèƒ½
    pub allowed_capabilities: Vec<WasiCapability>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum WasiCapability {
    /// æ¨™æº–å…¥å‡ºåŠ›ã®ã¿
    Stdio,
    /// ç’°å¢ƒå¤‰æ•°èª­ã¿å–ã‚Š
    EnvRead,
    /// æ™‚è¨ˆ
    Clock,
    /// ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆæš—å·å­¦çš„ã«å®‰å…¨ï¼‰
    Random,
}

impl Default for WasmPluginConfig {
    fn default() -> Self {
        Self {
            fuel_limit: 1_000_000,  // 100ä¸‡å‘½ä»¤
            time_limit: Duration::from_secs(5),
            memory_limit: 10 * 1024 * 1024,  // 10MB
            allowed_capabilities: vec![WasiCapability::Stdio],  // æœ€å°é™
        }
    }
}

impl WasmPlugin {
    pub async fn execute(&self, input: &str) -> Result<String> {
        let mut config = Config::new();
        config.consume_fuel(true);
        config.epoch_interruption(true);
        
        let engine = Engine::new(&config)?;
        let module = Module::from_file(&engine, &self.config.module_path)?;
        
        let wasi = WasiCtxBuilder::new()
            .inherit_stdio()  // æœ€å°é™
            .build();
        
        let mut store = Store::new(&engine, wasi);
        store.add_fuel(self.config.fuel_limit)?;
        
        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãå®Ÿè¡Œ
        tokio::time::timeout(
            self.config.time_limit,
            self.execute_module(&mut store, &module, input)
        ).await??
    }
}
```

**æˆæœç‰©**:
- [ ] `codex-rs/wasm-plugin/` (æ–°è¦ã‚¯ãƒ¬ãƒ¼ãƒˆ)
- [ ] fuel/time/memoryåˆ¶é™å®Ÿè£…
- [ ] capability-based WASIåˆ¶å¾¡

#### Day 18-19: MCPæ¨©é™æ˜ç¤ºåŒ–

**å®Ÿè£…**:
```rust
// codex-rs/mcp-server/src/permission.rs (æ–°è¦)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpPermission {
    pub server_name: String,
    pub tool_name: String,
    pub risk_level: RiskLevel,
    pub requires_approval: bool,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum RiskLevel {
    Low,     // ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã®ã¿
    Medium,  // ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿å–ã‚Š
    High,    // ãƒ•ã‚¡ã‚¤ãƒ«æ›¸ãè¾¼ã¿
    Critical, // ã‚·ã‚¹ãƒ†ãƒ å¤‰æ›´ãƒ»ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
}

impl McpPermission {
    pub fn requires_user_approval(&self, profile: &SecurityProfile) -> bool {
        match (profile, self.risk_level) {
            (SecurityProfile::Trusted, _) => false,
            (_, RiskLevel::Critical) => true,
            (SecurityProfile::Offline, RiskLevel::High) => true,
            _ => self.requires_approval,
        }
    }
}
```

**æˆæœç‰©**:
- [ ] `codex-rs/mcp-server/src/permission.rs`
- [ ] ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«è‡ªå‹•åˆ¤å®š
- [ ] æ‰¿èªãƒ•ãƒ­ãƒ¼å®Ÿè£…

#### Day 20-21: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å¢ƒç•Œãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

```markdown
# docs/plugin-architecture.md

## ãƒ—ãƒ©ã‚°ã‚¤ãƒ³æ¨©é™ãƒ¢ãƒ‡ãƒ«

### Low-privilege: WASMå†…å®Ÿè¡Œ
**ç”¨é€”**: ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå¤‰æ›ã€ãƒ­ãƒ¼ã‚«ãƒ«è¨ˆç®—
**åˆ¶é™**:
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ã‚¯ã‚»ã‚¹: âŒï¼ˆæ˜ç¤ºçš„ã«æ¸¡ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®ã¿ï¼‰
- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯: âŒ
- ãƒ—ãƒ­ã‚»ã‚¹ç”Ÿæˆ: âŒ
- ç‡ƒæ–™åˆ¶é™: 100ä¸‡å‘½ä»¤
- æ™‚é–“åˆ¶é™: 5ç§’
- ãƒ¡ãƒ¢ãƒªåˆ¶é™: 10MB

### High-privilege: MCP (stdio/gRPC)
**ç”¨é€”**: ã‚·ã‚¹ãƒ†ãƒ çµ±åˆã€å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹ã€ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ 
**è¦ä»¶**:
- ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«æ˜ç¤ºï¼ˆLow/Medium/High/Criticalï¼‰
- Criticalæ“ä½œã¯å¿…ãšãƒ¦ãƒ¼ã‚¶ãƒ¼æ‰¿èª
- å…¨æ“ä½œã‚’ç›£æŸ»ãƒ­ã‚°ã«è¨˜éŒ²
```

**æˆæœç‰©**:
- [ ] `docs/plugin-architecture.md`
- [ ] ä½¿ã„åˆ†ã‘ãƒ•ãƒ­ãƒ¼ãƒãƒ£ãƒ¼ãƒˆ

---

### Week 4: ä¾›çµ¦é–ï¼†ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯

#### Day 22-24: cargo-dist + ç½²å + SBOM

**è¨­å®š**:
```toml
# Cargo.toml
[workspace.metadata.dist]
cargo-dist-version = "0.18.0"
ci = ["github"]
installers = ["shell", "powershell", "msi", "homebrew"]
targets = [
    "x86_64-unknown-linux-musl",
    "x86_64-pc-windows-msvc",
    "aarch64-apple-darwin",
    "x86_64-apple-darwin",
]

# ã‚³ãƒ¼ãƒ‰ã‚µã‚¤ãƒ³è¨­å®š
[workspace.metadata.dist.signing]
sign = true
cosign = true
```

**CIè¨­å®š**:
```yaml
# .github/workflows/release.yml
- name: Build with cargo-dist
  run: cargo dist build --artifacts all
  
- name: Sign artifacts with cosign
  run: |
    cosign sign-blob --bundle codex.sig target/dist/codex
    
- name: Generate SBOM
  run: |
    cargo auditable build --release
    cargo cyclonedx --format json > sbom.json
    
- name: Attach to release
  run: |
    gh release upload ${{ github.ref }} codex.sig sbom.json
```

**READMEè¿½è¨˜**:
```markdown
## ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¨æ¤œè¨¼

### ãƒã‚¤ãƒŠãƒªæ¤œè¨¼

\`\`\`bash
# ç½²åæ¤œè¨¼
cosign verify-blob --bundle codex.sig codex

# SBOMç¢ºèª
jq . sbom.json | less
\`\`\`
```

**æˆæœç‰©**:
- [ ] cargo-distè¨­å®š
- [ ] cosignç½²åè‡ªå‹•åŒ–
- [ ] SBOMç”Ÿæˆè‡ªå‹•åŒ–
- [ ] READMEã«æ¤œè¨¼æ‰‹é †

#### Day 25-26: A/Bãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯

**å®Ÿè£…**:
```rust
// codex-rs/benches/comparison.rs (æ–°è¦)
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use std::process::Command;

fn bench_cold_start(c: &mut Criterion) {
    let mut group = c.benchmark_group("cold_start");
    
    // Rustç‰ˆ
    group.bench_function("rust", |b| {
        b.iter(|| {
            Command::new("codex-cli")
                .arg("--version")
                .output()
                .unwrap();
        });
    });
    
    // Nodeç‰ˆ
    group.bench_function("node", |b| {
        b.iter(|| {
            Command::new("codex")
                .arg("--version")
                .output()
                .unwrap();
        });
    });
    
    group.finish();
}

fn bench_warm_execution(c: &mut Criterion) {
    // ãƒ—ãƒ­ã‚»ã‚¹å¸¸é§çŠ¶æ…‹ã§ã®å¿œç­”é€Ÿåº¦
}

fn bench_parallel_agents(c: &mut Criterion) {
    // 8ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¸¦åˆ—å®Ÿè¡Œ
    c.bench_with_input(
        BenchmarkId::new("agents", "8_parallel"),
        &8,
        |b, &num_agents| {
            b.iter(|| {
                // IntegratedTaskRunner ã§è¤‡åˆã‚¿ã‚¹ã‚¯
            });
        },
    );
}

criterion_group!(benches, bench_cold_start, bench_warm_execution, bench_parallel_agents);
criterion_main!(benches);
```

**CIçµ±åˆ**:
```yaml
# .github/workflows/benchmark.yml
- name: Run benchmarks
  run: |
    cd codex-rs
    cargo bench --bench comparison > bench_results.txt
    
- name: Check regression
  run: |
    # Cold start ãŒ 80ms è¶…ãˆãŸã‚‰å¤±æ•—
    python scripts/check_bench_regression.py bench_results.txt
```

**æˆæœç‰©**:
- [ ] `codex-rs/benches/comparison.rs`
- [ ] CIè‡ªå‹•ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯
- [ ] åŠ£åŒ–æ¤œçŸ¥ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

#### Day 27-28: DeepResearchå“è³ªè£…ç½®

**å®Ÿè£…**:
```rust
// codex-rs/deep-research/src/dedup.rs (æ–°è¦)
use std::collections::{HashMap, HashSet};

/// SimHash + MinHash ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰é‡è¤‡æ¤œå‡º
pub struct HybridDeduplicator {
    simhash_threshold: u32,  // ãƒãƒŸãƒ³ã‚°è·é›¢
    minhash_threshold: f64,  // Jaccardé¡ä¼¼åº¦
}

impl HybridDeduplicator {
    pub fn deduplicate(&self, sources: Vec<Source>) -> Vec<Source> {
        let mut unique = Vec::new();
        let mut seen_simhash = HashSet::new();
        
        for source in sources {
            let sim = self.simhash(&source.snippet);
            
            // ç¬¬1æ®µéšï¼šSimHashã§ç²—ã„ãƒ•ã‚£ãƒ«ã‚¿
            if seen_simhash.iter().any(|&existing| {
                hamming_distance(sim, existing) < self.simhash_threshold
            }) {
                continue;
            }
            
            // ç¬¬2æ®µéšï¼šMinHashã§ç²¾å¯†ãƒã‚§ãƒƒã‚¯
            let minhash = self.minhash(&source.snippet);
            let is_duplicate = unique.iter().any(|existing: &Source| {
                let existing_minhash = self.minhash(&existing.snippet);
                jaccard_similarity(&minhash, &existing_minhash) > self.minhash_threshold
            });
            
            if !is_duplicate {
                seen_simhash.insert(sim);
                unique.push(source);
            }
        }
        
        unique
    }
}

// codex-rs/deep-research/src/bias_detection.rs (æ–°è¦)
#[derive(Debug, Clone)]
pub struct BiasDetectionConfig {
    pub max_domain_ratio: f32,      // 0.3 = 30%
    pub domain_whitelist: Vec<String>,
    pub domain_blacklist: Vec<String>,
}

pub fn detect_bias(
    sources: &[Source],
    config: &BiasDetectionConfig,
) -> BiasReport {
    let mut domain_counts = HashMap::new();
    
    for source in sources {
        let domain = extract_domain(&source.url);
        *domain_counts.entry(domain.clone()).or_insert(0) += 1;
        
        // ãƒ–ãƒ©ãƒƒã‚¯ãƒªã‚¹ãƒˆãƒã‚§ãƒƒã‚¯
        if config.domain_blacklist.contains(&domain) {
            warnings.push(format!("Blacklisted domain detected: {domain}"));
        }
    }
    
    // åã‚Šæ¤œå‡º
    for (domain, count) in &domain_counts {
        let ratio = *count as f32 / sources.len() as f32;
        if ratio > config.max_domain_ratio 
            && !config.domain_whitelist.contains(domain) 
        {
            warnings.push(format!(
                "Domain '{domain}' dominates: {:.1}% (threshold: {:.1}%)",
                ratio * 100.0,
                config.max_domain_ratio * 100.0
            ));
        }
    }
    
    BiasReport { /* ... */ }
}

// codex-rs/deep-research/src/cache.rs (æ–°è¦)
use dashmap::DashMap;
use std::time::{Duration, Instant};

pub struct ResearchCache {
    url_to_content: DashMap<String, CachedContent>,
}

struct CachedContent {
    content: String,
    timestamp: Instant,
    ttl: Duration,
}

impl ResearchCache {
    pub async fn get_or_fetch(
        &self,
        url: &str,
        provider: &dyn ResearchProvider,
    ) -> Result<String> {
        // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒã‚§ãƒƒã‚¯
        if let Some(cached) = self.url_to_content.get(url) {
            if cached.timestamp.elapsed() < cached.ttl {
                return Ok(cached.content.clone());
            }
        }
        
        // ãƒ•ã‚§ãƒƒãƒ
        match provider.retrieve(url).await {
            Ok(content) => {
                self.url_to_content.insert(
                    url.to_string(),
                    CachedContent {
                        content: content.clone(),
                        timestamp: Instant::now(),
                        ttl: Duration::from_secs(3600),  // 1æ™‚é–“
                    },
                );
                Ok(content)
            }
            Err(e) => {
                // å¤±æ•—ã‚‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ï¼ˆçŸ­ã„TTLï¼‰
                self.url_to_content.insert(
                    url.to_string(),
                    CachedContent {
                        content: format!("ERROR: {e}"),
                        timestamp: Instant::now(),
                        ttl: Duration::from_secs(60),  // 1åˆ†
                    },
                );
                Err(e)
            }
        }
    }
}
```

**æˆæœç‰©**:
- [ ] `codex-rs/wasm-plugin/` (æ–°è¦)
- [ ] `codex-rs/deep-research/src/dedup.rs`
- [ ] `codex-rs/deep-research/src/bias_detection.rs`
- [ ] `codex-rs/deep-research/src/cache.rs`

#### Day 29-30: çµ±åˆï¼†ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

**æœ€çµ‚ãƒ­ã‚°ä½œæˆï¼†ã‚³ãƒŸãƒƒãƒˆ**

---

## ğŸ¯ å®šé‡ç›®æ¨™ï¼ˆè¨¼æ˜ãƒã‚¤ãƒ³ãƒˆï¼‰

| é …ç›® | Nodeç‰ˆå®Ÿæ¸¬ | Rustç‰ˆç›®æ¨™ | è¨ˆæ¸¬æ–¹æ³• |
|---|---|---|---|
| **Cold start** | ~200ms | **<80ms** | `hyperfine "codex --version"` |
| **ãƒã‚¤ãƒŠãƒªã‚µã‚¤ã‚º** | ~50MB | **<15MB** | `ls -lh` after strip |
| **å¸¸é§RSS** | ~100MB | **<30MB** | `ps aux \| grep codex` |
| **ä¾å­˜è„†å¼±æ€§** | npm audit | **0ä»¶** | `cargo deny check` |
| **ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹** | ãƒ—ãƒ­ã‚»ã‚¹åˆ†é›¢ | **OSç›´çµ** | è„±ç„E2E |
| **é…å¸ƒä¾å­˜** | nodeå¿…é ˆ | **å˜ä¸€ãƒã‚¤ãƒŠãƒª** | ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã‚µã‚¤ã‚º |

---

## ğŸ“‹ å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆï¼ˆ30æ—¥å¾Œã®çŠ¶æ…‹ï¼‰

### ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼ˆWeek 1ï¼‰
- [ ] `SecurityProfile::Offline` ãŒæ—¢å®š
- [ ] ç¸®é€€ä»•æ§˜ãŒ3ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã§å‹•ä½œ
- [ ] è„±ç„E2Eï¼ˆãƒãƒƒãƒˆ/æ›¸è¾¼/spawnï¼‰ãŒCIã§ç·‘
- [ ] ç›£æŸ»ãƒ­ã‚°ã« operation/target/decision/reason

### è¦³æ¸¬æ€§ï¼ˆWeek 2ï¼‰
- [ ] æ§‹é€ åŒ–ãƒ­ã‚°ï¼ˆtask_id/agent/profile/decisionï¼‰
- [ ] ãƒ¡ãƒˆãƒªã‚¯ã‚¹5ç¨®ï¼ˆcount/duration/active/errors/denialsï¼‰
- [ ] OTLP ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆè¨­å®š
- [ ] bounded mailbox + ãƒãƒƒã‚¯ãƒ—ãƒ¬ãƒƒã‚·ãƒ£

### æ‹¡å¼µï¼ˆWeek 3ï¼‰
- [ ] WASM: fuel/time/memoryåˆ¶é™
- [ ] WASM: capability-based WASI
- [ ] MCP: ãƒªã‚¹ã‚¯ãƒ¬ãƒ™ãƒ«è‡ªå‹•åˆ¤å®š
- [ ] ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å¢ƒç•Œãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

### é…å¸ƒãƒ»æ€§èƒ½ï¼ˆWeek 4ï¼‰
- [ ] cargo-dist + cosignç½²å
- [ ] SBOMè‡ªå‹•ç”Ÿæˆ
- [ ] README ã«æ¤œè¨¼æ‰‹é †
- [ ] A/Bãƒ™ãƒ³ãƒï¼ˆRust vs Nodeï¼‰
- [ ] CIè‡ªå‹•ãƒ™ãƒ³ãƒï¼‹åŠ£åŒ–æ¤œçŸ¥
- [ ] DeepResearch: ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰é‡è¤‡æ’é™¤
- [ ] DeepResearch: ãƒã‚¤ã‚¢ã‚¹æ¤œå‡º
- [ ] DeepResearch: å¤±æ•—ã‚­ãƒ£ãƒƒã‚·ãƒ¥

---

## ğŸ” å®Ÿè£…ã®ã‚³ãƒ„ï¼ˆãƒœãƒ–ã«ã‚ƒã‚“å¼ï¼‰

### 1. Least-PrivilegeåŸå‰‡
```rust
// âŒ ç·©ã„æ—¢å®šå€¤
impl Default for SecurityProfile {
    fn default() -> Self {
        Self::WorkspaceWrite  // å±é™ºï¼
    }
}

// âœ… å³æ ¼ãªæ—¢å®šå€¤
impl Default for SecurityProfile {
    fn default() -> Self {
        Self::Offline  // å®‰å…¨å´
    }
}
```

### 2. Fail-safeè¨­è¨ˆ
```rust
// ã‚¨ãƒ©ãƒ¼æ™‚ã¯å¿…ãšå®‰å…¨å´ã«
pub fn resolve_permission(&self, operation: &Operation) -> Permission {
    self.policy.check(operation)
        .unwrap_or(Permission::Deny)  // ã‚¨ãƒ©ãƒ¼=æ‹’å¦
}
```

### 3. ç›£æŸ»ãƒ­ã‚°ã¨ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã®åŒååŒ–
```rust
// ãƒ­ã‚°
audit.profile = "Offline";

// ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
## Offline Profile
- Network: DENIED
```
â†’ **åŒã˜èª**ãªã‚‰èªçŸ¥è² è·ãŒæ¿€æ¸›

### 4. åœæ­¢å¯èƒ½ãªæ§‹é€ åŒ–ä¸¦è¡Œæ€§
```rust
use tokio_util::sync::CancellationToken;

pub async fn process_with_cancel(
    &mut self,
    task: String,
    cancel: CancellationToken,
) -> Result<String> {
    tokio::select! {
        result = self.process_task(task) => result,
        _ = cancel.cancelled() => {
            self.cleanup().await?;  // å¾Œå§‹æœ«å¿…é ˆ
            Err(anyhow!("Cancelled"))
        }
    }
}
```

---

## ğŸš€ npmç‹¬è‡ªãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼†CursorIDEå°å…¥

### Step 1: ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†ç¢ºèª

```bash
# Rustç‰ˆã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ï¼ˆnightlyã§å®Ÿè¡Œä¸­...ï¼‰
cd C:\Users\downl\Desktop\codex-official\codex-rs
cargo install --path cli --force
```

### Step 2: npmç‰ˆç‹¬è‡ªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ä½œæˆ

```bash
# package.jsonã‚’æ›´æ–°
cd C:\Users\downl\Desktop\codex-main\codex-main\codex-cli

# ãƒãƒ¼ã‚¸ãƒ§ãƒ³æ›´æ–°ï¼ˆç‹¬è‡ªè­˜åˆ¥ï¼‰
npm version 0.40.1-custom.1

# ãƒ­ãƒ¼ã‚«ãƒ«ãƒ“ãƒ«ãƒ‰
npm run build

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install -g .
```

### Step 3: CursorIDEçµ±åˆ

```bash
# Cursorè¨­å®šãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
cd "%APPDATA%\Cursor\User"

# settings.json ã«è¿½åŠ 
{
  "codex.cli.path": "C:\\Users\\downl\\.cargo\\bin\\codex-cli.exe",
  "codex.cli.args": ["--profile", "workspace-write"],
  "codex.enableCustom": true
}
```

---

**ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆæ™‚åˆ»**: 2025å¹´10æœˆ8æ—¥ 0:25 JST  
**ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹**: ğŸ“‹ 30æ—¥ã‚¹ãƒ—ãƒªãƒ³ãƒˆè¨ˆç”»ç­–å®šå®Œäº†

ãƒœãƒ–ã«ã‚ƒã‚“ã®èµ¤ãƒšãƒ³æŒ‡å°ã‚’å…¨é¢çš„ã«å–ã‚Šå…¥ã‚Œã¦ã€  
**"Rustã§ãªãã‚ƒé”æˆä¸èƒ½"ã‚’å®šé‡ã§è¨¼æ˜ã™ã‚‹30æ—¥è¨ˆç”»**ã‚’ç«‹ã¦ãŸã§ï¼

æ¬¡ã¯å®Ÿéš›ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å®Œäº†ã‚’å¾…ã£ã¦ã€npmï¼†CursorIDEã«å°å…¥ã—ã¦ã„ãã§ã€œ ğŸš€

