# Codex Rust実装 30日スプリント実装計画

**日時**: 2025年10月8日 0:20 JST  
**作業者**: AI Assistant (なんJ風) + ボブにゃんの赤ペン指導  
**目的**: "Rustでなきゃ無理"を定量で証明する実務レベルCLI構築

参考：
- ボブにゃん赤ペンフィードバック
- gemini-cli: https://github.com/zapabob/gemini-cli
- 公式Codex: https://github.com/openai/codex

---

## 🎯 完成ライン（DoD: Definition of Done）

以下の5点が揃えば **"Rustでなきゃ達成不能"** が証明できる：

1. ✅ **既定プロファイル=Offline**、明文化 & 実装 & テスト が一致
2. ✅ **CI脱獄E2E** が 3系統で緑、拒否理由が監査ログに残る
3. ✅ **`cosign verify` + `sbom.json`** の検証手順がREADMEに記載
4. ✅ **A/Bベンチダッシュボード** で Cold<80ms / RSS<30MB を常時満たす
5. ✅ **WASM と MCP の権限差** が人間に説明できるレベルで明記

---

## 📅 30日スプリント計画（触れる成果物優先）

### Week 1: セキュリティ基盤（Offline既定化）

#### Day 1-2: 既定プロファイル変更

**実装**:
```rust
// codex-rs/protocol/src/protocol.rs
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum SecurityProfile {
    /// 既定：ネット遮断 + ディスク読み取りのみ
    #[default]
    Offline,
    /// ワークスペース書き込み可（ネット遮断）
    WorkspaceWrite,
    /// ネット読み取り可
    NetReadOnly,
    /// フル権限（要明示）
    Trusted,
}

impl Default for SandboxPolicy {
    fn default() -> Self {
        // Offline = ReadOnly + network_access=false
        SandboxPolicy::ReadOnly
    }
}
```

**ドキュメント**:
```markdown
# docs/security-profiles.md

## Default Profile: Offline(ReadOnly)

| 操作 | 許可 | 理由 |
|---|---|---|
| ファイル読み取り | ✅ | コード解析に必要 |
| ファイル書き込み | ❌ | ワークスペース外保護 |
| ネットワークアクセス | ❌ | データ漏洩防止 |
| プロセス生成 | ❌ | 許可リストのみ |

### プロファイル昇格
`--profile workspace-write` または `/profile workspace-write` で一時昇格
```

**成果物**:
- [ ] `codex-rs/protocol/src/security_profile.rs` (新規)
- [ ] `docs/security-profiles.md` (新規)
- [ ] テスト: `test_default_is_offline()`

#### Day 3-4: 縮退仕様の実装

**実装**:
```rust
// codex-rs/core/src/executor/sandbox.rs
pub fn get_effective_sandbox(policy: SandboxPolicy) -> EffectiveSandbox {
    #[cfg(target_os = "linux")]
    if landlock::is_available() {
        return EffectiveSandbox::Landlock(policy);
    }
    
    #[cfg(target_os = "macos")]
    if seatbelt::is_available() {
        return EffectiveSandbox::Seatbelt(policy);
    }
    
    #[cfg(target_os = "windows")]
    if appcontainer::is_available() {
        return EffectiveSandbox::AppContainer(policy);
    }
    
    // 縮退：全環境共通の最小限制御
    EffectiveSandbox::Degraded {
        network_blocked: true,
        workspace_only_write: true,
        spawn_denied: true,
    }
}
```

**縮退表**:
```markdown
| 環境 | 優先実装 | 縮退先 |
|---|---|---|
| Linux | Landlock | seccomp-bpf |
| macOS | Seatbelt | process sandbox |
| Windows | AppContainer | Job Object |
| その他 | - | ネット遮断+spawn制限 |
```

**成果物**:
- [ ] `codex-rs/core/src/executor/degraded_sandbox.rs` (新規)
- [ ] `docs/sandbox-degradation.md` (新規)

#### Day 5-7: 脱獄E2Eテスト

**実装**:
```rust
// codex-rs/core/tests/suite/sandbox_escape.rs (新規)
use pretty_assertions::assert_eq;

#[tokio::test]
async fn test_sandbox_blocks_network_dns() {
    let result = execute_sandboxed("nslookup google.com").await;
    assert!(result.is_err());
    // 監査ログに記録されることを確認
    let audit = get_last_audit_entry();
    assert_eq!(audit.operation, "network_access");
    assert_eq!(audit.decision, Decision::Denied);
    assert!(audit.reason.contains("Offline profile"));
}

#[tokio::test]
async fn test_sandbox_blocks_network_tcp() {
    let result = execute_sandboxed("curl http://example.com").await;
    assert!(result.is_err());
}

#[tokio::test]
async fn test_sandbox_blocks_unauthorized_write() {
    let result = execute_sandboxed("echo test > /etc/passwd").await;
    assert!(result.is_err());
    let audit = get_last_audit_entry();
    assert_eq!(audit.decision, Decision::Denied);
}

#[tokio::test]
async fn test_sandbox_blocks_process_spawn() {
    let result = execute_sandboxed("bash -c 'python malicious.py'").await;
    assert!(result.is_err());
}
```

**CI設定**:
```yaml
# .github/workflows/security-tests.yml (新規)
name: Security Tests
on: [push, pull_request]

jobs:
  sandbox-escape-tests:
    name: Sandbox Escape Tests (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@nightly
      - name: Run sandbox escape tests
        run: |
          cd codex-rs
          cargo test --test sandbox_escape -- --test-threads=1
      - name: Verify audit logs created
        run: |
          test -f audit.log || exit 1
```

**成果物**:
- [ ] `codex-rs/core/tests/suite/sandbox_escape.rs`
- [ ] `.github/workflows/security-tests.yml`
- [ ] 3系統テスト全てパス

---

### Week 2: 監査ログ＆観測性

#### Day 8-10: 監査ログv1

**実装**:
```rust
// codex-rs/audit/src/lib.rs (新規クレート)
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditEntry {
    /// タイムスタンプ（ISO 8601）
    pub timestamp: DateTime<Utc>,
    /// タスクID
    pub task_id: String,
    /// エージェントタイプ
    pub agent_type: String,
    /// セキュリティプロファイル
    pub profile: String,
    /// 操作種別
    pub operation: Operation,
    /// 対象（マスク済み）
    pub target: String,
    /// 決定
    pub decision: Decision,
    /// 理由
    pub reason: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Operation {
    FileRead,
    FileWrite,
    NetworkAccess,
    ProcessSpawn,
    Other(String),
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Decision {
    Allowed,
    Denied,
}

/// プライバシー配慮：パス内のユーザー名をマスク
pub fn sanitize_path(path: &Path) -> String {
    let path_str = path.display().to_string();
    
    // Windows: C:\Users\username → C:\Users\[USER]
    #[cfg(windows)]
    {
        if let Ok(username) = std::env::var("USERNAME") {
            return path_str.replace(&username, "[USER]");
        }
    }
    
    // Unix: /home/username → /home/[USER]
    #[cfg(unix)]
    {
        if let Ok(home) = std::env::var("HOME") {
            return path_str.replace(&home, "[HOME]");
        }
    }
    
    path_str
}

/// 監査ログライター
pub struct AuditLogger {
    log_path: PathBuf,
}

impl AuditLogger {
    pub fn new(log_path: PathBuf) -> Self {
        Self { log_path }
    }
    
    pub fn log(&self, entry: AuditEntry) -> std::io::Result<()> {
        use std::io::Write;
        let mut file = std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_path)?;
        
        writeln!(file, "{}", serde_json::to_string(&entry)?)?;
        Ok(())
    }
}
```

**成果物**:
- [ ] `codex-rs/audit/` (新規クレート)
- [ ] 必須フィールド4点セット実装
- [ ] プライバシーマスキング実装

#### Day 11-12: 構造化ログ＆メトリクス

**実装**:
```rust
// codex-rs/supervisor/src/metrics.rs (新規)
use opentelemetry::metrics::{Counter, Gauge, Histogram};

pub struct SupervisorMetrics {
    pub task_execution_count: Counter<u64>,
    pub task_execution_duration: Histogram<f64>,
    pub active_agents: Gauge<u64>,
    pub errors_total: Counter<u64>,
    pub denials_total: Counter<u64>,
}

// codex-rs/supervisor/src/integrated.rs に追加
use tracing::{info_span, instrument};

#[instrument(skip(self), fields(
    task_type = %self.get_task_type(&task),
    agent_count = self.agent_manager.get_all_states().len()
))]
pub fn execute_task(
    &mut self,
    task: TaskType,
) -> Pin<Box<dyn Future<Output = Result<TaskExecutionResult>> + '_>> {
    Box::pin(async move {
        let start = std::time::Instant::now();
        
        // メトリクス記録
        self.metrics.task_execution_count.add(1, &[]);
        
        // ... 実装 ...
        
        self.metrics.task_execution_duration.record(
            start.elapsed().as_secs_f64(),
            &[]
        );
        
        Ok(result)
    })
}
```

**成果物**:
- [ ] `codex-rs/supervisor/src/metrics.rs`
- [ ] OTLP エクスポート設定
- [ ] 5種類のメトリクス実装

#### Day 13-14: bounded mailbox + バックプレッシャ

**実装**:
```rust
// codex-rs/supervisor/src/subagent.rs 更新
use tokio::sync::{mpsc, Semaphore};

pub struct SubAgent {
    agent_type: AgentType,
    state: AgentState,
    tx: mpsc::Sender<AgentMessage>,  // bounded に変更
    rx: mpsc::Receiver<AgentMessage>,
}

impl SubAgent {
    pub fn new(agent_type: AgentType, mailbox_size: usize) -> Self {
        let (tx, rx) = mpsc::channel(mailbox_size);  // bounded: 既定32
        // ...
    }
}

#[derive(Debug, Clone)]
pub enum MailboxFullPolicy {
    /// ブロックして待機
    Block,
    /// 古いメッセージを削除
    DropOldest,
    /// 新しいメッセージを拒否
    DropNew,
}

pub struct SubAgentManager {
    agents: HashMap<AgentType, SubAgent>,
    semaphore: Arc<Semaphore>,  // 同時実行数制限
    mailbox_full_policy: MailboxFullPolicy,
}

impl SubAgentManager {
    pub fn new_with_config(
        max_concurrent: usize,
        mailbox_size: usize,
        full_policy: MailboxFullPolicy,
    ) -> Self {
        Self {
            agents: HashMap::new(),
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
            mailbox_full_policy: full_policy,
        }
    }
}
```

**成果物**:
- [ ] bounded channel実装
- [ ] Semaphoreによるスロットル
- [ ] MailboxFullPolicy設定化

---

### Week 3: 拡張境界（WASM/MCP分離）

#### Day 15-17: WASM プラグインレール

**実装**:
```rust
// codex-rs/wasm-plugin/src/lib.rs (新規クレート)
use wasmtime::{Config, Engine, Linker, Module, Store};
use wasmtime_wasi::{WasiCtx, WasiCtxBuilder};

pub struct WasmPlugin {
    engine: Engine,
    module: Module,
    config: WasmPluginConfig,
}

#[derive(Debug, Clone)]
pub struct WasmPluginConfig {
    /// 燃料制限（命令数）
    pub fuel_limit: u64,
    /// 時間制限
    pub time_limit: Duration,
    /// メモリ制限（バイト）
    pub memory_limit: usize,
    /// 許可するWASI機能
    pub allowed_capabilities: Vec<WasiCapability>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum WasiCapability {
    /// 標準入出力のみ
    Stdio,
    /// 環境変数読み取り
    EnvRead,
    /// 時計
    Clock,
    /// ランダム（暗号学的に安全）
    Random,
}

impl Default for WasmPluginConfig {
    fn default() -> Self {
        Self {
            fuel_limit: 1_000_000,  // 100万命令
            time_limit: Duration::from_secs(5),
            memory_limit: 10 * 1024 * 1024,  // 10MB
            allowed_capabilities: vec![WasiCapability::Stdio],  // 最小限
        }
    }
}

impl WasmPlugin {
    pub async fn execute(&self, input: &str) -> Result<String> {
        let mut config = Config::new();
        config.consume_fuel(true);
        config.epoch_interruption(true);
        
        let engine = Engine::new(&config)?;
        let module = Module::from_file(&engine, &self.config.module_path)?;
        
        let wasi = WasiCtxBuilder::new()
            .inherit_stdio()  // 最小限
            .build();
        
        let mut store = Store::new(&engine, wasi);
        store.add_fuel(self.config.fuel_limit)?;
        
        // タイムアウト付き実行
        tokio::time::timeout(
            self.config.time_limit,
            self.execute_module(&mut store, &module, input)
        ).await??
    }
}
```

**成果物**:
- [ ] `codex-rs/wasm-plugin/` (新規クレート)
- [ ] fuel/time/memory制限実装
- [ ] capability-based WASI制御

#### Day 18-19: MCP権限明示化

**実装**:
```rust
// codex-rs/mcp-server/src/permission.rs (新規)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct McpPermission {
    pub server_name: String,
    pub tool_name: String,
    pub risk_level: RiskLevel,
    pub requires_approval: bool,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum RiskLevel {
    Low,     // データ処理のみ
    Medium,  // ファイル読み取り
    High,    // ファイル書き込み
    Critical, // システム変更・ネットワーク
}

impl McpPermission {
    pub fn requires_user_approval(&self, profile: &SecurityProfile) -> bool {
        match (profile, self.risk_level) {
            (SecurityProfile::Trusted, _) => false,
            (_, RiskLevel::Critical) => true,
            (SecurityProfile::Offline, RiskLevel::High) => true,
            _ => self.requires_approval,
        }
    }
}
```

**成果物**:
- [ ] `codex-rs/mcp-server/src/permission.rs`
- [ ] リスクレベル自動判定
- [ ] 承認フロー実装

#### Day 20-21: プラグイン境界ドキュメント

```markdown
# docs/plugin-architecture.md

## プラグイン権限モデル

### Low-privilege: WASM内実行
**用途**: データ処理、フォーマット変換、ローカル計算
**制限**:
- ファイルアクセス: ❌（明示的に渡されたデータのみ）
- ネットワーク: ❌
- プロセス生成: ❌
- 燃料制限: 100万命令
- 時間制限: 5秒
- メモリ制限: 10MB

### High-privilege: MCP (stdio/gRPC)
**用途**: システム統合、外部サービス、ファイルシステム
**要件**:
- リスクレベル明示（Low/Medium/High/Critical）
- Critical操作は必ずユーザー承認
- 全操作を監査ログに記録
```

**成果物**:
- [ ] `docs/plugin-architecture.md`
- [ ] 使い分けフローチャート

---

### Week 4: 供給鎖＆ベンチマーク

#### Day 22-24: cargo-dist + 署名 + SBOM

**設定**:
```toml
# Cargo.toml
[workspace.metadata.dist]
cargo-dist-version = "0.18.0"
ci = ["github"]
installers = ["shell", "powershell", "msi", "homebrew"]
targets = [
    "x86_64-unknown-linux-musl",
    "x86_64-pc-windows-msvc",
    "aarch64-apple-darwin",
    "x86_64-apple-darwin",
]

# コードサイン設定
[workspace.metadata.dist.signing]
sign = true
cosign = true
```

**CI設定**:
```yaml
# .github/workflows/release.yml
- name: Build with cargo-dist
  run: cargo dist build --artifacts all
  
- name: Sign artifacts with cosign
  run: |
    cosign sign-blob --bundle codex.sig target/dist/codex
    
- name: Generate SBOM
  run: |
    cargo auditable build --release
    cargo cyclonedx --format json > sbom.json
    
- name: Attach to release
  run: |
    gh release upload ${{ github.ref }} codex.sig sbom.json
```

**README追記**:
```markdown
## インストールと検証

### バイナリ検証

\`\`\`bash
# 署名検証
cosign verify-blob --bundle codex.sig codex

# SBOM確認
jq . sbom.json | less
\`\`\`
```

**成果物**:
- [ ] cargo-dist設定
- [ ] cosign署名自動化
- [ ] SBOM生成自動化
- [ ] READMEに検証手順

#### Day 25-26: A/Bベンチマーク

**実装**:
```rust
// codex-rs/benches/comparison.rs (新規)
use criterion::{black_box, criterion_group, criterion_main, Criterion, BenchmarkId};
use std::process::Command;

fn bench_cold_start(c: &mut Criterion) {
    let mut group = c.benchmark_group("cold_start");
    
    // Rust版
    group.bench_function("rust", |b| {
        b.iter(|| {
            Command::new("codex-cli")
                .arg("--version")
                .output()
                .unwrap();
        });
    });
    
    // Node版
    group.bench_function("node", |b| {
        b.iter(|| {
            Command::new("codex")
                .arg("--version")
                .output()
                .unwrap();
        });
    });
    
    group.finish();
}

fn bench_warm_execution(c: &mut Criterion) {
    // プロセス常駐状態での応答速度
}

fn bench_parallel_agents(c: &mut Criterion) {
    // 8エージェント並列実行
    c.bench_with_input(
        BenchmarkId::new("agents", "8_parallel"),
        &8,
        |b, &num_agents| {
            b.iter(|| {
                // IntegratedTaskRunner で複合タスク
            });
        },
    );
}

criterion_group!(benches, bench_cold_start, bench_warm_execution, bench_parallel_agents);
criterion_main!(benches);
```

**CI統合**:
```yaml
# .github/workflows/benchmark.yml
- name: Run benchmarks
  run: |
    cd codex-rs
    cargo bench --bench comparison > bench_results.txt
    
- name: Check regression
  run: |
    # Cold start が 80ms 超えたら失敗
    python scripts/check_bench_regression.py bench_results.txt
```

**成果物**:
- [ ] `codex-rs/benches/comparison.rs`
- [ ] CI自動ベンチマーク
- [ ] 劣化検知スクリプト

#### Day 27-28: DeepResearch品質装置

**実装**:
```rust
// codex-rs/deep-research/src/dedup.rs (新規)
use std::collections::{HashMap, HashSet};

/// SimHash + MinHash ハイブリッド重複検出
pub struct HybridDeduplicator {
    simhash_threshold: u32,  // ハミング距離
    minhash_threshold: f64,  // Jaccard類似度
}

impl HybridDeduplicator {
    pub fn deduplicate(&self, sources: Vec<Source>) -> Vec<Source> {
        let mut unique = Vec::new();
        let mut seen_simhash = HashSet::new();
        
        for source in sources {
            let sim = self.simhash(&source.snippet);
            
            // 第1段階：SimHashで粗いフィルタ
            if seen_simhash.iter().any(|&existing| {
                hamming_distance(sim, existing) < self.simhash_threshold
            }) {
                continue;
            }
            
            // 第2段階：MinHashで精密チェック
            let minhash = self.minhash(&source.snippet);
            let is_duplicate = unique.iter().any(|existing: &Source| {
                let existing_minhash = self.minhash(&existing.snippet);
                jaccard_similarity(&minhash, &existing_minhash) > self.minhash_threshold
            });
            
            if !is_duplicate {
                seen_simhash.insert(sim);
                unique.push(source);
            }
        }
        
        unique
    }
}

// codex-rs/deep-research/src/bias_detection.rs (新規)
#[derive(Debug, Clone)]
pub struct BiasDetectionConfig {
    pub max_domain_ratio: f32,      // 0.3 = 30%
    pub domain_whitelist: Vec<String>,
    pub domain_blacklist: Vec<String>,
}

pub fn detect_bias(
    sources: &[Source],
    config: &BiasDetectionConfig,
) -> BiasReport {
    let mut domain_counts = HashMap::new();
    
    for source in sources {
        let domain = extract_domain(&source.url);
        *domain_counts.entry(domain.clone()).or_insert(0) += 1;
        
        // ブラックリストチェック
        if config.domain_blacklist.contains(&domain) {
            warnings.push(format!("Blacklisted domain detected: {domain}"));
        }
    }
    
    // 偏り検出
    for (domain, count) in &domain_counts {
        let ratio = *count as f32 / sources.len() as f32;
        if ratio > config.max_domain_ratio 
            && !config.domain_whitelist.contains(domain) 
        {
            warnings.push(format!(
                "Domain '{domain}' dominates: {:.1}% (threshold: {:.1}%)",
                ratio * 100.0,
                config.max_domain_ratio * 100.0
            ));
        }
    }
    
    BiasReport { /* ... */ }
}

// codex-rs/deep-research/src/cache.rs (新規)
use dashmap::DashMap;
use std::time::{Duration, Instant};

pub struct ResearchCache {
    url_to_content: DashMap<String, CachedContent>,
}

struct CachedContent {
    content: String,
    timestamp: Instant,
    ttl: Duration,
}

impl ResearchCache {
    pub async fn get_or_fetch(
        &self,
        url: &str,
        provider: &dyn ResearchProvider,
    ) -> Result<String> {
        // キャッシュチェック
        if let Some(cached) = self.url_to_content.get(url) {
            if cached.timestamp.elapsed() < cached.ttl {
                return Ok(cached.content.clone());
            }
        }
        
        // フェッチ
        match provider.retrieve(url).await {
            Ok(content) => {
                self.url_to_content.insert(
                    url.to_string(),
                    CachedContent {
                        content: content.clone(),
                        timestamp: Instant::now(),
                        ttl: Duration::from_secs(3600),  // 1時間
                    },
                );
                Ok(content)
            }
            Err(e) => {
                // 失敗もキャッシュ（短いTTL）
                self.url_to_content.insert(
                    url.to_string(),
                    CachedContent {
                        content: format!("ERROR: {e}"),
                        timestamp: Instant::now(),
                        ttl: Duration::from_secs(60),  // 1分
                    },
                );
                Err(e)
            }
        }
    }
}
```

**成果物**:
- [ ] `codex-rs/wasm-plugin/` (新規)
- [ ] `codex-rs/deep-research/src/dedup.rs`
- [ ] `codex-rs/deep-research/src/bias_detection.rs`
- [ ] `codex-rs/deep-research/src/cache.rs`

#### Day 29-30: 統合＆ドキュメント

**最終ログ作成＆コミット**

---

## 🎯 定量目標（証明ポイント）

| 項目 | Node版実測 | Rust版目標 | 計測方法 |
|---|---|---|---|
| **Cold start** | ~200ms | **<80ms** | `hyperfine "codex --version"` |
| **バイナリサイズ** | ~50MB | **<15MB** | `ls -lh` after strip |
| **常駐RSS** | ~100MB | **<30MB** | `ps aux \| grep codex` |
| **依存脆弱性** | npm audit | **0件** | `cargo deny check` |
| **サンドボックス** | プロセス分離 | **OS直結** | 脱獄E2E |
| **配布依存** | node必須 | **単一バイナリ** | ダウンロードサイズ |

---

## 📋 実装チェックリスト（30日後の状態）

### セキュリティ（Week 1）
- [ ] `SecurityProfile::Offline` が既定
- [ ] 縮退仕様が3プラットフォームで動作
- [ ] 脱獄E2E（ネット/書込/spawn）がCIで緑
- [ ] 監査ログに operation/target/decision/reason

### 観測性（Week 2）
- [ ] 構造化ログ（task_id/agent/profile/decision）
- [ ] メトリクス5種（count/duration/active/errors/denials）
- [ ] OTLP エクスポート設定
- [ ] bounded mailbox + バックプレッシャ

### 拡張（Week 3）
- [ ] WASM: fuel/time/memory制限
- [ ] WASM: capability-based WASI
- [ ] MCP: リスクレベル自動判定
- [ ] プラグイン境界ドキュメント

### 配布・性能（Week 4）
- [ ] cargo-dist + cosign署名
- [ ] SBOM自動生成
- [ ] README に検証手順
- [ ] A/Bベンチ（Rust vs Node）
- [ ] CI自動ベンチ＋劣化検知
- [ ] DeepResearch: ハイブリッド重複排除
- [ ] DeepResearch: バイアス検出
- [ ] DeepResearch: 失敗キャッシュ

---

## 🔍 実装のコツ（ボブにゃん式）

### 1. Least-Privilege原則
```rust
// ❌ 緩い既定値
impl Default for SecurityProfile {
    fn default() -> Self {
        Self::WorkspaceWrite  // 危険！
    }
}

// ✅ 厳格な既定値
impl Default for SecurityProfile {
    fn default() -> Self {
        Self::Offline  // 安全側
    }
}
```

### 2. Fail-safe設計
```rust
// エラー時は必ず安全側に
pub fn resolve_permission(&self, operation: &Operation) -> Permission {
    self.policy.check(operation)
        .unwrap_or(Permission::Deny)  // エラー=拒否
}
```

### 3. 監査ログとドキュメントの同名化
```rust
// ログ
audit.profile = "Offline";

// ドキュメント
## Offline Profile
- Network: DENIED
```
→ **同じ語**なら認知負荷が激減

### 4. 停止可能な構造化並行性
```rust
use tokio_util::sync::CancellationToken;

pub async fn process_with_cancel(
    &mut self,
    task: String,
    cancel: CancellationToken,
) -> Result<String> {
    tokio::select! {
        result = self.process_task(task) => result,
        _ = cancel.cancelled() => {
            self.cleanup().await?;  // 後始末必須
            Err(anyhow!("Cancelled"))
        }
    }
}
```

---

## 🚀 npm独自バージョン＆CursorIDE導入

### Step 1: グローバルインストール完了確認

```bash
# Rust版インストール（nightlyで実行中...）
cd C:\Users\downl\Desktop\codex-official\codex-rs
cargo install --path cli --force
```

### Step 2: npm版独自パッケージ作成

```bash
# package.jsonを更新
cd C:\Users\downl\Desktop\codex-main\codex-main\codex-cli

# バージョン更新（独自識別）
npm version 0.40.1-custom.1

# ローカルビルド
npm run build

# グローバルインストール
npm install -g .
```

### Step 3: CursorIDE統合

```bash
# Cursor設定ディレクトリ
cd "%APPDATA%\Cursor\User"

# settings.json に追加
{
  "codex.cli.path": "C:\\Users\\downl\\.cargo\\bin\\codex-cli.exe",
  "codex.cli.args": ["--profile", "workspace-write"],
  "codex.enableCustom": true
}
```

---

**ドキュメント作成時刻**: 2025年10月8日 0:25 JST  
**ステータス**: 📋 30日スプリント計画策定完了

ボブにゃんの赤ペン指導を全面的に取り入れて、  
**"Rustでなきゃ達成不能"を定量で証明する30日計画**を立てたで！

次は実際のインストール完了を待って、npm＆CursorIDEに導入していくで〜 🚀

