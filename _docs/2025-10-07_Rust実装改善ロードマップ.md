# Codex Rust実装 改善ロードマップ

**日時**: 2025年10月8日 0:10 JST  
**作業者**: AI Assistant (なんJ風) + ボブにゃんのフィードバック  
**目的**: 実務レベルのCLI型AIシステムへの昇華

---

## 🎯 なぜRustなのか（再確認）

ボブにゃんの言う通り、**Codexが
Rustを選んだのはほぼ必然**や：

### 三点セット
1. **単一バイナリ配布** - 依存地獄からの解放
2. **ネイティブな権限制御** - OS直結の安全策
3. **低オーバーヘッド** - LLMはクラウド側で重いから、クライアント側は軽く

### 現状の成果
✅ `enum`による厳格な型システム  
✅ `Box::pin`で再帰async制御  
✅ Tokioによる並列・進捗管理  
✅ ユニットテスト24/24パス（100%）  

**→ "壊れにくい土台"は既に形成済み**

---

## 🚀 実装優先度（実務目線）

### 優先度1: 脅威モデル → 既定サンドボックス 🔐

**現状**:
- `SandboxPolicy`は定義済み
- 実装は部分的（Linux/macOS/Windows）

**やるべきこと**:

#### 1.1 プロファイル設計
```rust
pub enum SecurityProfile {
    Offline,        // ネットワーク完全拒否
    ReadOnly,       // ディスク読み取りのみ
    NetReadOnly,    // ネット読み取り+ディスク読み取り
    WorkspaceWrite, // ワークスペース書き込み可
    Trusted,        // フル権限（要明示）
}
```

#### 1.2 プラットフォーム別実装
```
Linux:
  └─ seccomp/landlock
     ├─ syscall deny-list
     ├─ file path allowlist
     └─ network namespace isolation

macOS:
  └─ Seatbelt (既に codex-rs/core/src/seatbelt.rs に基礎あり)
     ├─ profile enhancement
     └─ file-read-metadata 制限

Windows:
  └─ AppContainer/Job Object
     ├─ codex-rs/linux-sandbox を参考に windows-sandbox 作成
     └─ ACL による権限制限
```

#### 1.3 脱獄E2Eテスト
```rust
#[test]
fn test_sandbox_blocks_network() {
    // curl/wget などがブロックされることを確認
}

#[test]
fn test_sandbox_blocks_unauthorized_write() {
    // /etc/ などへの書き込みが拒否されることを確認
}

#[test]
fn test_sandbox_blocks_process_spawn() {
    // 許可されていないプロセス生成が拒否されることを確認
}
```

**実装場所**: `codex-rs/execpolicy/`, `codex-rs/linux-sandbox/`

---

### 優先度2: 拡張の土台（WASM vs MCP）⚙️

**方針**:
- **WASM(WASI)**: 未署名プラグイン用（安全境界明確）
- **MCP**: 外部プロセス拡張用（権限明示化）

#### 2.1 WASM拡張システム
```rust
// codex-rs/wasm-plugin/ (新規)
use wasmtime::{Engine, Module, Store};

pub struct WasmPlugin {
    module: Module,
    // WASI権限設定
    wasi_config: WasiConfig,
}

impl WasmPlugin {
    pub async fn execute(&self, task: &str) -> Result<String> {
        // WASM内で実行、ホストへの影響なし
    }
}
```

#### 2.2 危険度別レール分け
```
低権限（データ処理）
  └─ WASM内実行
     └─ ファイルアクセス: 明示的に渡されたデータのみ

中権限（ツール呼び出し）
  └─ MCP (stdio)
     └─ ホワイトリストコマンドのみ

高権限（システム操作）
  └─ 明示的審査 + ログ
     └─ ユーザー承認必須
```

**実装場所**: `codex-rs/mcp-client/`, 新規 `codex-rs/wasm-plugin/`

---

### 優先度3: 観測可能性（Observability）📊

**現状**:
- `codex-rs/otel/` に基礎あり
- OpenTelemetry対応済み

#### 3.1 構造化ログ強化
```rust
// 既存の tracing を拡張
use tracing::{info_span, instrument};

#[instrument(skip(agent_manager))]
pub async fn execute_task(&mut self, task: TaskType) -> Result<TaskExecutionResult> {
    let _span = info_span!("task_execution", 
        task_type = %task,
        agent_count = self.agent_manager.get_all_states().len()
    ).entered();
    
    // ... 実装 ...
}
```

#### 3.2 メトリクス収集
```rust
// codex-rs/otel/src/metrics.rs (新規)
pub struct TaskMetrics {
    pub execution_count: Counter<u64>,
    pub execution_duration: Histogram<f64>,
    pub agent_active: Gauge<u64>,
    pub errors_total: Counter<u64>,
}
```

#### 3.3 監査ログ
```rust
// codex-rs/core/src/audit_log.rs (新規)
pub struct AuditEntry {
    pub timestamp: DateTime<Utc>,
    pub agent_type: AgentType,
    pub operation: Operation,
    pub target: String,
    pub decision: Decision,  // Allowed/Denied
    pub reason: Option<String>,
}

// プライバシー配慮
pub fn sanitize_for_log(path: &Path) -> String {
    // ユーザー名やセンシティブ情報をマスク
    path.display().to_string()
        .replace(&env::var("USERNAME").unwrap_or_default(), "[USER]")
}
```

**実装場所**: `codex-rs/otel/`, 新規 `codex-rs/audit/`

---

### 優先度4: 配布とサプライチェーン📦

#### 4.1 cargo-dist導入
```toml
# Cargo.toml
[workspace.metadata.dist]
cargo-dist-version = "0.18.0"
ci = ["github"]
installers = ["shell", "powershell", "msi"]
targets = ["x86_64-unknown-linux-musl", "x86_64-pc-windows-msvc", "aarch64-apple-darwin"]
```

#### 4.2 SBOM生成
```bash
# CI/CD に組み込み
cargo install cargo-auditable
cargo auditable build --release
cargo cyclonedx --format json > sbom.json
```

#### 4.3 依存チェック
```toml
# deny.toml (新規)
[advisories]
vulnerability = "deny"
unmaintained = "warn"

[licenses]
allow = ["MIT", "Apache-2.0", "BSD-3-Clause"]
deny = ["GPL-3.0"]
```

**実装場所**: `.github/workflows/`, `deny.toml`

---

### 優先度5: 性能目標と実測📈

#### 目標値（ベンチマーク）
```
✅ Cold start     < 80ms
✅ 常駐 RSS       < 30MB
✅ 100req/min     スパイクなし
✅ Agent並列(8)   < 500ms
```

#### 5.1 ベンチマーク実装
```rust
// codex-rs/supervisor/benches/agent_parallel.rs (新規)
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_parallel_agents(c: &mut Criterion) {
    c.bench_function("8 agents parallel", |b| {
        b.iter(|| {
            // 8エージェント並列実行
        });
    });
}

criterion_group!(benches, benchmark_parallel_agents);
criterion_main!(benches);
```

#### 5.2 バックプレッシャ実装
```rust
// bounded channel でスロットル
use tokio::sync::Semaphore;

pub struct ThrottledAgentManager {
    agents: HashMap<AgentType, SubAgent>,
    semaphore: Arc<Semaphore>,  // 同時実行数制限
}

impl ThrottledAgentManager {
    pub fn new(max_concurrent: usize) -> Self {
        Self {
            agents: HashMap::new(),
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
        }
    }
    
    pub async fn dispatch_task(&mut self, agent_type: AgentType, task: String) -> Result<String> {
        let _permit = self.semaphore.acquire().await?;  // スロットル
        self.agents.get_mut(&agent_type)?.process_task(task).await
    }
}
```

**実装場所**: `codex-rs/supervisor/benches/`, `codex-rs/supervisor/src/subagent.rs`

---

### 優先度6: メッセージング堅牢化💬

#### 6.1 bounded mailbox
```rust
// 現在の unbounded を bounded に変更
pub struct SubAgent {
    agent_type: AgentType,
    state: AgentState,
    tx: mpsc::Sender<AgentMessage>,      // bounded
    rx: mpsc::Receiver<AgentMessage>,
}

impl SubAgent {
    pub fn new(agent_type: AgentType, mailbox_size: usize) -> Self {
        let (tx, rx) = mpsc::channel(mailbox_size);  // bounded
        // ...
    }
}
```

#### 6.2 キャンセル伝播
```rust
use tokio_util::sync::CancellationToken;

pub struct SubAgent {
    // ...
    cancel_token: CancellationToken,
}

impl SubAgent {
    pub async fn process_task_cancelable(
        &mut self,
        task: String,
        timeout: Duration,
    ) -> Result<String> {
        tokio::select! {
            result = self.process_task(task) => result,
            _ = tokio::time::sleep(timeout) => Err(anyhow!("Task timeout")),
            _ = self.cancel_token.cancelled() => Err(anyhow!("Task cancelled")),
        }
    }
}
```

#### 6.3 集約ポリシー設定可能化
```rust
// 既に MergeStrategy はあるので、より詳細に
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AggregationConfig {
    pub strategy: MergeStrategy,
    pub timeout: Duration,
    pub min_success_ratio: f32,  // Voting用
    pub score_threshold: f64,    // HighestScore用
}
```

**実装場所**: `codex-rs/supervisor/src/subagent.rs`, `codex-rs/supervisor/src/types.rs`

---

### 優先度7: DeepResearch品質装置🔬

#### 7.1 重複除去（SimHash/MinHash）
```rust
// codex-rs/deep-research/src/dedup.rs (新規)
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

pub fn simhash(text: &str) -> u64 {
    let mut hasher = DefaultHasher::new();
    text.hash(&mut hasher);
    hasher.finish()
}

pub fn deduplicate_sources(sources: Vec<Source>) -> Vec<Source> {
    let mut seen = HashSet::new();
    sources.into_iter()
        .filter(|s| {
            let hash = simhash(&s.snippet);
            seen.insert(hash)
        })
        .collect()
}
```

#### 7.2 出典バイアス検知
```rust
// codex-rs/deep-research/src/bias_detection.rs (新規)
pub struct BiasReport {
    pub domain_distribution: HashMap<String, usize>,
    pub low_trust_ratio: f32,
    pub warnings: Vec<String>,
}

pub fn detect_bias(sources: &[Source]) -> BiasReport {
    let mut domains = HashMap::new();
    for source in sources {
        let domain = extract_domain(&source.url);
        *domains.entry(domain).or_insert(0) += 1;
    }
    
    // 同一ドメイン30%超で警告
    let max_ratio = domains.values().max().unwrap_or(&0) as f32 / sources.len() as f32;
    let mut warnings = Vec::new();
    if max_ratio > 0.3 {
        warnings.push(format!("Single domain dominates: {:.1}%", max_ratio * 100.0));
    }
    
    BiasReport {
        domain_distribution: domains,
        low_trust_ratio: 0.0,  // TODO: 信頼スコア実装
        warnings,
    }
}
```

#### 7.3 キャッシュ層
```rust
// codex-rs/deep-research/src/cache.rs (新規)
use dashmap::DashMap;

pub struct ResearchCache {
    url_to_summary: DashMap<String, String>,
    url_to_embedding: DashMap<String, Vec<f32>>,
}

impl ResearchCache {
    pub async fn get_or_fetch(&self, url: &str, provider: &dyn ResearchProvider) -> Result<String> {
        if let Some(cached) = self.url_to_summary.get(url) {
            return Ok(cached.clone());
        }
        
        let content = provider.retrieve(url).await?;
        self.url_to_summary.insert(url.to_string(), content.clone());
        Ok(content)
    }
}
```

**実装場所**: `codex-rs/deep-research/src/`

---

## ✅ 実務着地チェックリスト

ボブにゃん提示の5点セット：

### 1. 既定プロファイルドキュメント
```markdown
# Default Security Profile

## Offline Profile (既定)
- ✅ Network: DENIED
- ✅ File Read: ALLOWED (workspace only)
- ✅ File Write: DENIED
- ✅ Process Spawn: DENIED (except allowlist)
```

**場所**: `codex-rs/docs/security-profiles.md` (新規)

### 2. CIで脱獄テスト
```yaml
# .github/workflows/security-tests.yml
name: Security Tests
on: [push, pull_request]

jobs:
  sandbox-escape-tests:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4
      - name: Run sandbox escape tests
        run: cargo test --package codex-execpolicy -- --test-threads=1
```

### 3. パフォーマンスベンチマーク
```bash
# CI に組み込み
cargo bench
# 目標: Cold start <80ms, RSS <30MB
```

### 4. 監査ログ設計
```rust
// プライバシー配慮込み
pub struct SanitizedAuditLog {
    timestamp: String,
    operation: String,
    target: String,  // [USER] でマスク済み
    decision: String,
}
```

### 5. プラグイン分離ドキュメント
```markdown
# Plugin Architecture

## Low-privilege (WASM)
- Data processing
- Format conversion
- Local computation

## High-privilege (MCP)
- System integration
- External services
- Requires user approval
```

**場所**: `docs/plugin-architecture.md` (新規)

---

## 📊 実装スケジュール（推奨）

### Week 1-2: セキュリティ基盤
- [ ] SecurityProfile enum実装
- [ ] プラットフォーム別サンドボックス強化
- [ ] 脱獄E2Eテスト作成
- [ ] CI統合

### Week 3-4: 拡張システム
- [ ] WASM plugin基盤構築
- [ ] MCP権限明示化
- [ ] プラグインAPI設計

### Week 5-6: 観測性・品質
- [ ] 構造化ログ強化
- [ ] メトリクス収集
- [ ] 監査ログ実装
- [ ] DeepResearch品質装置

### Week 7-8: 配布・ベンチマーク
- [ ] cargo-dist導入
- [ ] SBOM生成自動化
- [ ] パフォーマンスベンチマーク
- [ ] Node版とのA/B比較

---

## 🎯 定量目標（証明ポイント）

ボブにゃんの言う **"Rustでなきゃ無理だった"** を証明する数値：

| 項目 | Node版 | Rust版目標 |
|---|---|---|
| バイナリサイズ | ~50MB (node含む) | <15MB |
| Cold start | ~200ms | <80ms |
| 常駐RSS | ~100MB | <30MB |
| 依存脆弱性 | npm audit | cargo deny (0件) |
| サンドボックス | プロセス分離のみ | OS直結制御 |
| 配布形式 | npm/node必須 | 単一バイナリ |

---

## 💡 実装のコツ（経験則）

### 1. 段階的セキュリティ
```rust
// 最初は ReadOnly で始めて、段階的に緩和
impl Default for SecurityProfile {
    fn default() -> Self {
        Self::ReadOnly  // 安全側に倒す
    }
}
```

### 2. Fail-safe設計
```rust
// エラー時は安全側に
pub fn resolve_permission(&self, operation: &Operation) -> Permission {
    match self.policy.check(operation) {
        Ok(perm) => perm,
        Err(_) => Permission::Deny,  // エラー=拒否
    }
}
```

### 3. テスタビリティ優先
```rust
// モック可能な設計
pub trait SandboxExecutor {
    async fn execute(&self, cmd: &str) -> Result<String>;
}

pub struct RealExecutor { /* ... */ }
pub struct MockExecutor { /* テスト用 */ }
```

---

## 🔗 参考実装・リソース

### Rustセキュリティ
- **Landlock**: https://landlock.io/
- **seccomp-rs**: https://github.com/tailhook/seccomp
- **AppContainer**: Windows SDK docs

### WASM拡張
- **wasmtime**: https://github.com/bytecodealliance/wasmtime
- **WASI**: https://wasi.dev/

### 観測性
- **tracing**: https://docs.rs/tracing/
- **OpenTelemetry**: https://opentelemetry.io/

### 配布
- **cargo-dist**: https://opensource.axo.dev/cargo-dist/
- **cargo-deny**: https://github.com/EmbarkStudios/cargo-deny

---

## 🎨 gemini-cli との差別化ポイント

参考: https://github.com/zapabob/gemini-cli

| 機能 | gemini-cli (Node) | Codex (Rust) |
|---|---|---|
| マルチエージェント | ✅ | ✅ (型安全) |
| サンドボックス | プロセス分離 | **OS直結制御** |
| 配布形式 | npm | **単一バイナリ** |
| 起動速度 | ~200ms | **<80ms目標** |
| メモリ使用 | ~100MB | **<30MB目標** |
| 拡張API | JavaScript | **WASM+MCP** |
| 型安全性 | TypeScript | **Rustコンパイル時** |

**→ Rust版の優位性を定量で証明**

---

## 📝 次のアクション

### 即座にやるべきこと（今週）
1. **セキュリティプロファイル実装** (`security-profiles.md` + コード)
2. **脱獄E2Eテスト** 追加
3. **パフォーマンスベンチマーク** 初版

### 中期（来月）
4. **WASM plugin基盤** 構築
5. **監査ログ** 実装
6. **cargo-dist** 導入

### 長期（3ヶ月）
7. **Node版A/B比較** レポート
8. **プロダクション環境** 実績
9. **コミュニティフィードバック** 反映

---

**ドキュメント作成時刻**: 2025年10月8日 0:15 JST  
**ステータス**: 📋 ロードマップ策定完了

ボブにゃんの指摘通り、**"Rustを選んだ趣味"から"Rustでなきゃ無理"** へのフェーズ移行を目指すで！

セキュリティ・観測性・性能の三本柱を定量で証明して、  
実務で安心して使えるCLI型AIシステムに育てていくんや 🚀

次は実際にコード実装していくで〜！

